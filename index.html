<title>Aquatic Grass Ecosystem Simulation with Crayfish</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: linear-gradient(to bottom, #FFDAB9 0%, #F0E68C 15%, #87CEFA 30%, #1E90FF 50%, #2E8B57 100%);
    }
    canvas {
        width: 100%;
        height: 100%;
    }
    #toolbar {
        position: fixed;
        top: 0;
        width: 100%;
        background-color: rgba(255, 255, 255, 0.8);
        text-align: center;
        padding: 5px;
        z-index: 1;
    }
    #toolbar button {
        margin: 0 10px;
        padding: 10px 20px;
        background: linear-gradient(to bottom, #6b8e23, #2e8b57);
        border: none;
        border-radius: 5px;
        color: white;
        cursor: pointer;
        font-family: 'Verdana', sans-serif;
        font-size: 14px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }
    #toolbar button:hover {
        background: linear-gradient(to bottom, #2e8b57, #6b8e23);
    }
</style>
</head>
<body>
<div id="toolbar">
    <button id="foodButton">üçì Food</button>
    <button id="minnowButton">üêü Minnow</button>
    <button id="crayfishButton">ü¶û Crayfish</button>
    <button id="snailButton">üêå Snail</button>
</div>
<canvas id="ecosystemCanvas"></canvas>
<script>
const canvas = document.getElementById('ecosystemCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const waterSurfaceHeight = canvas.height * 0.2; 
const pondBottomHeight = canvas.height * 0.07; 

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.prevX = x;
        this.prevY = y;
    }
}

class Grass {
    constructor(x, segments, length, rootHeight, zIndex) {
        this.segments = segments;
        this.points = [];
        this.color = this.getRandomGreenShade();
        this.zIndex = zIndex; 
        for (let i = 0; i < segments; i++) {
            this.points.push(new Point(x, rootHeight - i * (length / segments)));
        }
    }

    getRandomGreenShade() {
        const r = 34; 
        const g = Math.floor(Math.random() * 50) + 100;
        const b = 34;
        return `rgb(${r}, ${g}, ${b})`;
    }

    update(dt, bubbles, crayfishList) {
        const gravity = -9.8; 
        const damping = 0.99;

        for (let i = 1; i < this.points.length; i++) {
            let p = this.points[i];
            let vx = (p.x - p.prevX) * damping;
            let vy = (p.y - p.prevY) * damping;

            p.prevX = p.x;
            p.prevY = p.y;

            p.x += vx;
            p.y += vy + gravity * dt * dt;

            bubbles.forEach(bubble => {
                const dx = p.x - bubble.x;
                const dy = p.y - bubble.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < bubble.radius * 2) {
                    const force = 0.2 * (1 - dist / (bubble.radius * 2));
                    p.x += dx * force;
                    p.y += dy * force;
                }
            });

            crayfishList.forEach(crayfish => {
                const dx = p.x - crayfish.position.x;
                const dy = p.y - crayfish.position.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < crayfish.size * 1.5) {
                    const force = 0.7 * (1 - dist / (crayfish.size * 1.5));
                    p.x += dx * force;
                    p.y += dy * force;
                }
            });
        }

        for (let i = 0; i < this.points.length - 1; i++) {
            let p1 = this.points[i];
            let p2 = this.points[i + 1];
            let dx = p2.x - p1.x;
            let dy = p2.y - p1.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            let diff = (dist - 10) / dist / 2;

            if (i > 0) {
                p1.x += dx * diff;
                p1.y += dy * diff;
            }
            p2.x -= dx * diff;
            p2.y -= dy * diff;
        }

        this.points[0].x = this.points[0].prevX;
        this.points[0].y = this.points[0].prevY;
    }

    draw() {
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        for (let i = 1; i < this.points.length; i++) {
            ctx.lineTo(this.points[i].x, this.points[i].y);
        }
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

class Bubble {
    constructor(x, y) {
        this.x = Math.random() * canvas.width;
        this.y = canvas.height - pondBottomHeight;
        this.radius = Math.random() * 2 + 1;
        this.speed = Math.random() * 0.3 + 0.2;
    }

    update() {
        this.y -= this.speed;
        if (this.y < waterSurfaceHeight) {
            this.x = Math.random() * canvas.width;
            this.y = canvas.height - pondBottomHeight;
        }
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.fill();
    }
}

class FoodPellet {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 5;
        this.speed = 2;
        this.eaten = false;
        this.splashFrames = 5;
        this.splashFrame = 0;
        this.splashing = true;
        this.inWater = y >= waterSurfaceHeight; 
        this.horizontalDrift = (Math.random() - 0.5) * 0.5; 
    }

    update() {
        if (this.splashing && !this.inWater) {
            if (this.y >= waterSurfaceHeight) {
                this.splashing = false;
            } else {
                this.splashFrame++;
                if (this.splashFrame >= this.splashFrames) {
                    this.splashing = false;
                }
            }
        } else {
            if (!this.inWater && this.y >= waterSurfaceHeight) {
                this.inWater = true;
                this.speed *= 0.5; 
            }

            this.y += this.speed;

            if (this.inWater) {
                this.x += this.horizontalDrift;
            }
        }
    }

    draw() {
        if (this.splashing && !this.inWater) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.splashFrame * 2, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${1 - this.splashFrame / this.splashFrames})`;
            ctx.stroke();
        } else {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'brown';
            ctx.fill();
        }
    }
}

class Snail {
    constructor() {
        const side = Math.random();
        if (side < 0.5) {
            this.position = {
                x: Math.random() * canvas.width,
                y: canvas.height - pondBottomHeight + 5
            };
            this.direction = Math.random() > 0.5 ? 1 : -1;
            this.movingHorizontal = true;
        } else {
            this.position = {
                x: Math.random() > 0.5 ? 5 : canvas.width - 5,
                y: Math.random() * (canvas.height - pondBottomHeight - waterSurfaceHeight) + waterSurfaceHeight
            };
            this.direction = Math.random() > 0.5 ? 1 : -1;
            this.movingHorizontal = false;
        }
        this.speed = 0.1;
        this.size = 8;
        this.angle = 0;
    }

    update() {
        if (this.movingHorizontal) {
            this.position.x += this.speed * this.direction;
            if (this.position.x < 5 || this.position.x > canvas.width - 5) {
                this.direction *= -1;
            }
        } else {
            this.position.y += this.speed * this.direction;
            if (this.position.y < waterSurfaceHeight + 5 || this.position.y > canvas.height - pondBottomHeight - 5) {
                this.direction *= -1;
            }
        }
        this.angle += 0.02;

        if (Math.random() < 0.01) {
            bubbles.push(new Bubble(this.position.x, this.position.y));
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(this.angle);
        ctx.beginPath();
        for (let i = 0; i < Math.PI * 4; i += 0.1) {
            const radius = (this.size * i) / (Math.PI * 4);
            const x = radius * Math.cos(i);
            const y = radius * Math.sin(i);
            ctx.lineTo(x, y);
        }
        ctx.fillStyle = '#A0522D';
        ctx.fill();
        ctx.restore();
    }
}

class CrayfishSegment {
    constructor(x, y) {
        this.point = new Point(x, y);
    }
}

class Crayfish {
    constructor() {
        this.position = { x: Math.random() * canvas.width, y: Math.random() * (canvas.height - pondBottomHeight - waterSurfaceHeight) + waterSurfaceHeight };
        this.size = 5; 
        this.maxSize = Math.random() * 15 + 15; 
        this.segments = [];
        this.segmentLength = 10;
        this.numSegments = 5;
        this.color = 'rgb(205, 92, 92)';
        this.direction = Math.random() > 0.5 ? 1 : -1; 
        this.verticalDirection = Math.random() > 0.5 ? 1 : -1; 
        this.verticalSpeed = Math.random() * 0.2 + 0.1; 
        this.hungerLevel = 50; 
        this.maxHunger = 100;
        this.minHunger = 0;
        this.speed = Math.random() * 0.5 + 0.5; 
        for (let i = 0; i < this.numSegments; i++) {
            this.segments.push(new CrayfishSegment(this.position.x - i * this.segmentLength * this.direction, this.position.y));
        }
        this.age = 0;
        this.inWater = this.position.y >= waterSurfaceHeight;
        this.splashing = !this.inWater;
        this.splashFrame = 0;
        this.splashFrames = 5;
    }

    update(dt) {
        this.age += dt;
        if (this.age > 60) {
            this.reset();
        }

        let targetPellet = null;
        let targetMinnow = null;
        let minDistancePellet = 150;
        let minDistanceMinnow = 150;

        for (let pellet of foodPellets) {
            const dx = pellet.x - this.position.x;
            const dy = pellet.y - this.position.y;
            const distance = Math.hypot(dx, dy);

            if (distance < minDistancePellet) {
                minDistancePellet = distance;
                targetPellet = pellet;
            }
        }

        for (let minnow of minnowList) {
            const dx = minnow.position.x - this.position.x;
            const dy = minnow.position.y - this.position.y;
            const distance = Math.hypot(dx, dy);

            if (distance < minDistanceMinnow) {
                minDistanceMinnow = distance;
                targetMinnow = minnow;
            }
        }

        if (targetMinnow) {
            const angle = Math.atan2(targetMinnow.position.y - this.position.y, targetMinnow.position.x - this.position.x);
            this.position.x += Math.cos(angle) * this.speed * dt * 60;
            this.position.y += Math.sin(angle) * this.speed * dt * 60;
            this.direction = Math.cos(angle) >= 0 ? 1 : -1;

            if (minDistanceMinnow < this.size) {
                this.eat();
                const index = minnowList.indexOf(targetMinnow);
                if (index > -1) {
                    minnowList.splice(index, 1);
                }
            }
        } else if (targetPellet) {
            const angle = Math.atan2(targetPellet.y - this.position.y, targetPellet.x - this.position.x);
            this.position.x += Math.cos(angle) * this.speed * dt * 60;
            this.position.y += Math.sin(angle) * this.speed * dt * 60;
            this.direction = Math.cos(angle) >= 0 ? 1 : -1;
        } else {
            this.position.x += this.speed * this.direction * dt * 60;
            if (this.position.x < 0 || this.position.x > canvas.width) {
                this.direction *= -1; 
            }
        }

        if (this.position.y < waterSurfaceHeight + this.size) {
            this.position.y = waterSurfaceHeight + this.size;
        } else if (this.position.y > canvas.height - pondBottomHeight - this.size) {
            this.position.y = canvas.height - pondBottomHeight - this.size;
        }

        this.hungerLevel += dt * 0.2;
        if (this.hungerLevel >= this.maxHunger) {
            this.reset(); 
        }

        for (let i = 0; i < this.segments.length; i++) {
            let segment = this.segments[i].point;
            if (i === 0) {
                segment.prevX = segment.x;
                segment.prevY = segment.y;
                segment.x = this.position.x - (this.size / 2) * this.direction;
                segment.y = this.position.y;
            } else {
                let prevSegment = this.segments[i - 1].point;
                let dx = segment.x - prevSegment.x;
                let dy = segment.y - prevSegment.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let difference = this.segmentLength - dist;
                let percent = difference / dist / 2;
                let offsetX = dx * percent;
                let offsetY = dy * percent;

                segment.x += offsetX;
                segment.y += offsetY;

                prevSegment.x -= offsetX;
                prevSegment.y -= offsetY;
            }
        }

        if (!this.inWater) {
            this.position.y += 2;

            if (this.position.y >= waterSurfaceHeight) {
                this.inWater = true;
                this.splashing = true;
            }
        } else {
            if (this.splashing) {
                this.splashFrame++;
                if (this.splashFrame >= this.splashFrames) {
                    this.splashing = false;
                }
            }
        }
    }

    reset() {
        this.position.x = Math.random() * canvas.width;
        this.position.y = Math.random() * (canvas.height - pondBottomHeight - waterSurfaceHeight) + waterSurfaceHeight;
        this.size = 5;
        this.hungerLevel = 50; 
        this.age = 0;
    }

    eat() {
        if (this.canEat()) {
            this.hungerLevel -= 20;
            this.size += 0.5;
            if (this.size > this.maxSize) {
                this.size = this.maxSize;
            }

            const segmentsToAdd = Math.floor(this.size / 5);
            for (let i = 0; i < segmentsToAdd; i++) {
                this.numSegments += 1;
                const lastSegment = this.segments[this.segments.length - 1];
                const newSegment = new CrayfishSegment(
                    lastSegment.point.x - this.segmentLength * this.direction,
                    lastSegment.point.y
                );
                this.segments.push(newSegment);
            }
        }
    }

    canEat() {
        return this.hungerLevel > 10 && this.hungerLevel < this.maxHunger;
    }

    draw() {
        if (this.splashing) {
            ctx.beginPath();
            ctx.arc(this.position.x, waterSurfaceHeight, this.splashFrame * 3, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${1 - this.splashFrame / this.splashFrames})`;
            ctx.stroke();
        } else {
            ctx.fillStyle = this.color;
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.size / 5;

            for (let i = 0; i < this.segments.length; i++) {
                let segment = this.segments[i].point;
                let radius = Math.max(this.size - i, 0.5);
                ctx.beginPath();
                ctx.arc(segment.x, segment.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.beginPath();
            ctx.moveTo(this.position.x, this.position.y);
            ctx.lineTo(this.position.x + 10 * this.direction, this.position.y - 5);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(this.position.x, this.position.y);
            ctx.lineTo(this.position.x + 10 * this.direction, this.position.y + 5);
            ctx.stroke();
        }
    }
}

class Minnow {
    constructor() {
        this.position = {
            x: Math.random() * canvas.width,
            y: Math.random() * (canvas.height - pondBottomHeight - waterSurfaceHeight - 100) + waterSurfaceHeight + 50
        };
        this.velocity = {
            x: Math.random() * 2 - 1,
            y: Math.random() * 2 - 1
        };
        this.acceleration = { x: 0, y: 0 };
        this.maxSpeed = 2;       
        this.maxForce = 0.05;    
        this.size = 3;           
        this.zIndex = Math.random();
        this.inWater = this.position.y >= waterSurfaceHeight;
        this.splashing = !this.inWater;
        this.splashFrame = 0;
        this.splashFrames = 5;

        this.cohesionFactor = 0.01;  
        this.alignmentFactor = 0.125; 
        this.separationFactor = 0.2;  
    }

    flock(minnows) {
        const alignment = this.align(minnows);
        const cohesion = this.cohere(minnows);
        const separation = this.separate(minnows);
        const avoidCrayfishForce = this.avoidCrayfish(crayfishList);

        this.acceleration.x +=
            alignment.x * this.alignmentFactor +
            cohesion.x * this.cohesionFactor +
            separation.x * this.separationFactor +
            avoidCrayfishForce.x;
        this.acceleration.y +=
            alignment.y * this.alignmentFactor +
            cohesion.y * this.cohesionFactor +
            separation.y * this.separationFactor +
            avoidCrayfishForce.y;
    }

    align(minnows) {
        const perceptionRadius = 50;
        let steering = { x: 0, y: 0 };
        let total = 0;
        minnows.forEach(other => {
            const d = Math.hypot(this.position.x - other.position.x, this.position.y - other.position.y);
            if (other !== this && d < perceptionRadius) {
                steering.x += other.velocity.x;
                steering.y += other.velocity.y;
                total++;
            }
        });
        if (total > 0 && this.alignmentFactor !== 0) {
            steering.x /= total;
            steering.y /= total;

            steering.x -= this.velocity.x;
            steering.y -= this.velocity.y;

            const magnitude = Math.hypot(steering.x, steering.y);
            if (magnitude > this.maxForce) {
                steering.x = (steering.x / magnitude) * this.maxForce;
                steering.y = (steering.y / magnitude) * this.maxForce;
            }
        }
        return steering;
    }

    cohere(minnows) {
        const perceptionRadius = 50;
        let steering = { x: 0, y: 0 };
        let total = 0;
        minnows.forEach(other => {
            const d = Math.hypot(this.position.x - other.position.x, this.position.y - other.position.y);
            if (other !== this && d < perceptionRadius) {
                steering.x += other.position.x;
                steering.y += other.position.y;
                total++;
            }
        });
        if (total > 0) {
            steering.x /= total;
            steering.y /= total;

            steering.x -= this.position.x;
            steering.y -= this.position.y;

            const magnitude = Math.hypot(steering.x, steering.y);
            if (magnitude > this.maxForce) {
                steering.x = (steering.x / magnitude) * this.maxForce;
                steering.y = (steering.y / magnitude) * this.maxForce;
            }
        }
        return steering;
    }

    separate(minnows) {
        const perceptionRadius = 30; 
        let steering = { x: 0, y: 0 };
        let total = 0;
        minnows.forEach(other => {
            const d = Math.hypot(this.position.x - other.position.x, this.position.y - other.position.y);
            if (other !== this && d < perceptionRadius) {
                const diffX = this.position.x - other.position.x;
                const diffY = this.position.y - other.position.y;
                steering.x += diffX / (d * d); 
                steering.y += diffY / (d * d);
                total++;
            }
        });
        if (total > 0) {
            steering.x /= total;

            const magnitude = Math.hypot(steering.x, steering.y);
            if (magnitude > this.maxForce * 1.5) {
                steering.x = (steering.x / magnitude) * this.maxForce * 1.5;
                steering.y = (steering.y / magnitude) * this.maxForce * 1.5;
            }
        }
        return steering;
    }

    avoidCrayfish(crayfishList) {
        const perceptionRadius = 50;
        let steering = { x: 0, y: 0 };
        crayfishList.forEach(crayfish => {
            const d = Math.hypot(this.position.x - crayfish.position.x, this.position.y - crayfish.position.y);
            if (d < perceptionRadius + crayfish.size) {
                const diffX = this.position.x - crayfish.position.x;
                const diffY = this.position.y - crayfish.position.y;
                steering.x += diffX / (d * d);
                steering.y += diffY / (d * d);
            }
        });

        const magnitude = Math.hypot(steering.x, steering.y);
        if (magnitude > this.maxForce * 2) { 
            steering.x = (steering.x / magnitude) * this.maxForce * 2;
            steering.y = (steering.y / magnitude) * this.maxForce * 2;
        }
        return steering;
    }

    seekFoodPellets(foodPellets) {
        const perceptionRadius = 80;
        let closestPellet = null;
        let minDistance = perceptionRadius;

        foodPellets.forEach(pellet => {
            const d = Math.hypot(this.position.x - pellet.x, this.position.y - pellet.y);
            if (d < minDistance) {
                minDistance = d;
                closestPellet = pellet;
            }
        });

        if (closestPellet) {
            const desired = {
                x: closestPellet.x - this.position.x,
                y: closestPellet.y - this.position.y
            };
            const distance = Math.hypot(desired.x, desired.y);
            desired.x /= distance;
            desired.y /= distance;
            desired.x *= this.maxSpeed;
            desired.y *= this.maxSpeed;

            const steering = {
                x: desired.x - this.velocity.x,
                y: desired.y - this.velocity.y
            };

            const mag = Math.hypot(steering.x, steering.y);
            if (mag > this.maxForce * 0.5) {
                steering.x = (steering.x / mag) * this.maxForce * 0.5;
                steering.y = (steering.y / mag) * this.maxForce * 0.5;
            }

            this.acceleration.x += steering.x;
            this.acceleration.y += steering.y;

            if (distance < this.size + closestPellet.radius) {
                const index = foodPellets.indexOf(closestPellet);
                if (index > -1) {
                    foodPellets.splice(index, 1);
                }
            }
        }
    }

    update(foodPellets) {
        this.flock(minnowList);
        this.velocity.x += this.acceleration.x;
        this.velocity.y += this.acceleration.y;

        const speed = Math.hypot(this.velocity.x, this.velocity.y);
        if (speed > this.maxSpeed) {
            this.velocity.x = (this.velocity.x / speed) * this.maxSpeed;
            this.velocity.y = (this.velocity.y / speed) * this.maxSpeed;
        }

        this.position.x += this.velocity.x;
        this.position.y += this.velocity.y;

        this.acceleration.x = 0;
        this.acceleration.y = 0;

        if (this.position.y < waterSurfaceHeight + this.size) {
            this.position.y = waterSurfaceHeight + this.size;
            this.velocity.y *= -0.5; 
        } else if (this.position.y > canvas.height - pondBottomHeight - this.size) {
            this.position.y = canvas.height - pondBottomHeight - this.size;
            this.velocity.y *= -0.5;
        }

        if (this.position.x < this.size) {
            this.position.x = this.size;
            this.velocity.x *= -0.5;
        } else if (this.position.x > canvas.width - this.size) {
            this.position.x = canvas.width - this.size;
            this.velocity.x *= -0.5;
        }

        if (!this.inWater) {
            this.velocity.y += 0.2;
            this.position.y += this.velocity.y;

            if (this.position.y >= waterSurfaceHeight) {
                this.inWater = true;
                this.splashing = true;
            }
        } else {
            if (this.splashing) {
                this.splashFrame++;
                if (this.splashFrame >= this.splashFrames) {
                    this.splashing = false;
                }
            }
        }

        this.seekFoodPellets(foodPellets);
    }

    draw() {
        if (this.splashing) {
            ctx.beginPath();
            ctx.arc(this.position.x, waterSurfaceHeight, this.splashFrame * 2, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${1 - this.splashFrame / this.splashFrames})`;
            ctx.stroke();
        } else {
            ctx.save();
            ctx.translate(this.position.x, this.position.y);
            const angle = Math.atan2(this.velocity.y, this.velocity.x);
            ctx.rotate(angle);

            const gradient = ctx.createLinearGradient(-this.size, 0, this.size, 0);
            gradient.addColorStop(0, 'rgba(192, 192, 192, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(1, 'rgba(192, 192, 192, 1)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(-this.size * 2, -this.size);
            ctx.lineTo(this.size * 2, 0);
            ctx.lineTo(-this.size * 2, this.size);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
    }
}

class Guppy extends Minnow {
    constructor() {
        super();
        this.size = 5;         
        this.maxSpeed = Math.random() * 0.8 + 1.5;  
        this.maxForce = Math.random() * 0.03 + 0.05; 
        this.zIndex = Math.random();
        this.separationFactor = Math.random() * 1.0 + 2.0; 
    }

    draw() {
        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        const angle = Math.atan2(this.velocity.y, this.velocity.x);
        ctx.rotate(angle);

        ctx.beginPath();
        ctx.arc(0, 0, this.size * 2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 182, 193, 1)';
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(-this.size * 1.5, 0);
        ctx.lineTo(-this.size * 2.5, -this.size);
        ctx.lineTo(-this.size * 2.5, this.size);
        ctx.closePath();
        ctx.fillStyle = 'rgba(255, 105, 180, 1)';
        ctx.fill();

        ctx.restore();
    }
}

class SmallFish extends Minnow {
    constructor() {
        super();
        this.size = 2;
        this.maxSpeed = Math.random() * 0.6 + 2.0;  
        this.maxForce = Math.random() * 0.025 + 0.035; 
        this.color = 'rgba(30, 144, 255, 1)';
        this.separationFactor = Math.random() * 1.0 + 2.5; 
    }

    draw() {
        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        const angle = Math.atan2(this.velocity.y, this.velocity.x);
        ctx.rotate(angle);

        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

const grassBlades = [];
const numGrassBlades = 600; 
for (let i = 0; i < numGrassBlades; i++) {
    const x = Math.random() * canvas.width;
    const length = 50 + Math.random() * 150; 
    const segments = Math.floor(length / 10);
    const rootHeight = canvas.height - pondBottomHeight + Math.random() * pondBottomHeight; 
    const zIndex = Math.random(); 
    grassBlades.push(new Grass(x, segments, length, rootHeight, zIndex));
}

const bubbles = [];
const numBubbles = 30;
for (let i = 0; i < numBubbles; i++) {
    bubbles.push(new Bubble());
}

const crayfishList = [];
const numCrayfish = 5; 
for (let i = 0; i < numCrayfish; i++) {
    crayfishList.push(new Crayfish());
}

const minnowList = [];
const numMinnows = 250; 
for (let i = 0; i < numMinnows; i++) {
    const minnow = new Minnow();
    minnowList.push(minnow);
}

const guppyList = [];
const numGuppies = 10; 
for (let i = 0; i < numGuppies; i++) {
    guppyList.push(new Guppy());
}

const smallFishList = [];
const numSmallFish = 150; 
for (let i = 0; i < numSmallFish; i++) {
    smallFishList.push(new SmallFish());
}

const foodPellets = [];

const snailList = [];
const numSnails = 10; 
for (let i = 0; i < numSnails; i++) {
    snailList.push(new Snail());
}

function animate(time) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const skyGradient = ctx.createLinearGradient(0, 0, 0, waterSurfaceHeight);
    skyGradient.addColorStop(0, '#FFDAB9'); 
    skyGradient.addColorStop(1, '#F0E68C'); 
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, canvas.width, waterSurfaceHeight);

    const bottomGradient = ctx.createLinearGradient(0, canvas.height - pondBottomHeight, 0, canvas.height);
    bottomGradient.addColorStop(0, '#8B7765'); 
    bottomGradient.addColorStop(1, '#5C4033');
    ctx.fillStyle = bottomGradient;
    ctx.fillRect(0, canvas.height - pondBottomHeight, canvas.width, pondBottomHeight);

    const dt = 1 / 60; 

    const drawableObjects = [...grassBlades, ...crayfishList, ...minnowList, ...guppyList, ...smallFishList];
    drawableObjects.sort((a, b) => (a.zIndex || 0.5) - (b.zIndex || 0.5));

    drawableObjects.forEach(obj => {
        if (obj instanceof Grass) {
            obj.update(dt, bubbles, crayfishList);
        } else if (obj instanceof Crayfish) {
            obj.update(dt);
        } else if (obj instanceof Minnow) {
            obj.flock(minnowList); 
            obj.update(foodPellets);
        }
    });

    drawableObjects.forEach(obj => {
        obj.draw();
    });

    for (let bubble of bubbles) {
        bubble.update();
        bubble.draw();
    }

    for (let i = foodPellets.length - 1; i >= 0; i--) {
        let pellet = foodPellets[i];
        pellet.update();

        if (pellet.y > canvas.height || pellet.eaten) {
            foodPellets.splice(i, 1);
            continue;
        }

        crayfishList.forEach(crayfish => {
            const dx = pellet.x - crayfish.position.x;
            const dy = pellet.y - crayfish.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < crayfish.size) {
                if (crayfish.canEat()) {
                    crayfish.eat();
                    pellet.eaten = true;
                }
            }
        });

        pellet.draw();
    }
    
    const waterGradient = ctx.createLinearGradient(0, waterSurfaceHeight, 0, canvas.height - pondBottomHeight);
    waterGradient.addColorStop(0, 'rgba(64, 164, 223, 0.4)'); 
    waterGradient.addColorStop(1, 'rgba(34, 139, 34, 0.6)'); 
    ctx.fillStyle = waterGradient;
    ctx.fillRect(0, waterSurfaceHeight, canvas.width, canvas.height - waterSurfaceHeight - pondBottomHeight);
    
    for (let snail of snailList) {
        snail.update();
        snail.draw();
    }

    for (let fish of smallFishList) {
        fish.flock(smallFishList);
        fish.update(foodPellets);
        fish.draw();
    }

    guppyList.forEach(obj => {
        obj.flock(guppyList);
        obj.update(foodPellets);
        obj.draw();
    });

    requestAnimationFrame(animate);
}

animate();

canvas.addEventListener('mousemove', (e) => {
    const force = 2;
    for (let grass of grassBlades) {
        for (let point of grass.points) {
            let dx = point.x - e.clientX;
            let dy = point.y - e.clientY;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 50) {
                point.x += (dx / dist) * force;
                point.y += (dy / dist) * force;
            }
        }
    }
});

let placeMode = 'food'; 

document.getElementById('foodButton').addEventListener('click', () => {
    placeMode = 'food';
    updateToolbar();
});
document.getElementById('minnowButton').addEventListener('click', () => {
    placeMode = 'minnow';
    updateToolbar();
});
document.getElementById('crayfishButton').addEventListener('click', () => {
    placeMode = 'crayfish';
    updateToolbar();
});
document.getElementById('snailButton').addEventListener('click', () => {
    placeMode = 'snail';
    updateToolbar();
});

function updateToolbar() {
    document.getElementById('foodButton').classList.remove('active');
    document.getElementById('minnowButton').classList.remove('active');
    document.getElementById('crayfishButton').classList.remove('active');
    document.getElementById('snailButton').classList.remove('active');

    if (placeMode === 'food') {
        document.getElementById('foodButton').classList.add('active');
    } else if (placeMode === 'minnow') {
        document.getElementById('minnowButton').classList.add('active');
    } else if (placeMode === 'crayfish') {
        document.getElementById('crayfishButton').classList.add('active');
    } else if (placeMode === 'snail') {
        document.getElementById('snailButton').classList.add('active');
    }
}

updateToolbar();

canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (placeMode === 'food') {
        for (let i = 0; i < 3; i++) {
            const offsetX = (Math.random() - 0.5) * 10;
            const offsetY = (Math.random() - 0.5) * 10;
            const pellet = new FoodPellet(x + offsetX, y + offsetY - 50);
            pellet.inWater = false; 
            foodPellets.push(pellet);
        }
    } else if (placeMode === 'minnow') {
        const minnow = new Minnow();
        minnow.position.x = x;
        minnow.position.y = y - 50;
        minnow.inWater = false; 
        minnow.splashing = false;
        minnowList.push(minnow);
    } else if (placeMode === 'crayfish') {
        const crayfish = new Crayfish();
        crayfish.position.x = x;
        crayfish.position.y = y - 50;
        crayfish.inWater = false; 
        crayfish.splashing = false;
        crayfishList.push(crayfish);
    } else if (placeMode === 'snail') {
        const snail = new Snail();
        snail.position.x = x;
        snail.position.y = y - 50;
        snail.inWater = y >= waterSurfaceHeight; 
        snailList.push(snail);
    }
});

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
</body>
</html>