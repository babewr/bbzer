<style>
  /* Keeping all existing styles */
  body {
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    background-color: #000;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #stats-panel {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.7);
    padding: 15px;
    border-radius: 8px;
    color: white;
    font-family: Arial, sans-serif;
    z-index: 1000;
    border: 1px solid #444;
  }

  .stat {
    margin: 5px 0;
    font-size: 16px;
  }

  .dot {
    position: absolute;
    width: 1px;
    height: 1px;
    background: rgba(255,255,255,0.1);
    animation: float 20s linear infinite;
  }

  .tile-grid {
    position: absolute;
    top: -32px;
    left: -32px;
    display: grid;
    z-index: -1;
    overflow: auto;
    width: calc(100vw + 64px);
    height: calc(100vh + 64px);
  }

  .tile, .ice-tile {
    background-size: 100% 100%; 
    background-repeat: no-repeat;
    position: relative;
  }

  .tile {
    background-image: url('GrassTile (1).png');
  }

  .tree {
    position: absolute;
    width: 64px;
    height: 64px;
    background-image: url('gifmaker_me (4).gif');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 4;
    transform-origin: bottom center;
    animation: treeFloat 3s ease-in-out infinite;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
  }

  .campfire {
    position: absolute;
    width: 48px;
    height: 48px;
    background-image: url('gifmaker_me (6).gif');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 8px;
    left: 50%;
    transform: translateX(-50%);
    animation: fireLight 2s ease-in-out infinite;
  }

  .human {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Human 1.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 3;
    transition: all 0.5s ease;
  }

  .human-swim {
    background-image: url('Human Swim.png') !important;
    width: 32px !important;  
    height: 32px !important;
  }

  .kat-human {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Kat (1).png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 3;
    transition: all 0.5s ease;
  }

  .kat-human-swim {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Kat Swim.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 3;
    transition: all 0.5s ease;
  }

  .log {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Log.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  .house {
    position: absolute; 
    width: 64px;
    height: 64px;
    background-image: url('House.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 0;
  }

  .rock {
    position: absolute;
    width: 48px;
    height: 48px; 
    background-image: url('gifmaker_me (5).gif');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
  }

  .rock-item {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Rock Item.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  .farm-tile {
    width: 100%;
    height: 100%;
    background-image: url('FarmTile.png');
    background-size: cover;
    background-repeat: no-repeat;
    position: relative;
  }

  .farm-tile-cabbage {
    width: 100%;
    height: 100%;
    background-image: url('FarmTileCabbage.png');
    background-size: cover;
    background-repeat: no-repeat;
    position: relative;
  }

  .cabbage {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Cabbage (1).png');
    background-size: contain; 
    background-repeat: no-repeat;
    z-index: 2;
  }

  .water-tile {
    background-image: url('WaterTile.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    position: relative;
  }

  .fishing-dock {
    position: absolute;
    width: 64px;
    height: 64px;
    background-image: url('FishingDock.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 3;
    bottom: 0;
  }

  .fish {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('costume1 (5).png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  .windmill {
    position: absolute;
    width: 64px;
    height: 64px;
    background-image: url('gifmaker_me (7).gif');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 4;
    bottom: 0;
  }

  .iron-deposit {
    position: absolute;
    width: 48px;
    height: 48px;
    background-image: url('Iron deposit.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 0;
  }

  .cabbage-powder {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Cabbage Powder.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  .iron-item {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Iron Item.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  .stone-house {
    position: absolute; 
    width: 64px;
    height: 64px;
    background-image: url('Stone House (1).png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 0;
  }

  .blast-furnace {
    position: absolute;
    width: 64px;
    height: 64px;
    background-image: url('Blast Furnace.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 0;
  }

  .charcoal {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Charcoal.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  .sulfur-deposit {
    position: absolute;
    width: 48px;
    height: 48px;
    background-image: url('SulfurDeposit.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 0;
  }

  .sulfur-item {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Sulfur Item.png'); 
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  .crafting-table {
    position: absolute;
    width: 48px;
    height: 48px;
    background-image: url('Crafting Table.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 0;
  }

  .gunpowder {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Gunpowder.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  .musket {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Musket.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  .hunter {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Hunter.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 3;
    transition: all 0.5s ease;
  }

  .cow {
    position: absolute;
    width: 48px;
    height: 48px;
    background-image: url('costume2 (4).png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    transition: none;
  }

  .raw-beef {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Raw Beef.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  .mine {
    position: absolute;
    width: 48px;
    height: 48px;
    background-image: url('Mine.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 0;
  }

  .flat {
    position: absolute;
    width: 96px;  
    height: 96px; 
    background-image: url('Flat.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 5;  
    bottom: 0;
    left: 50%;   
    transform: translateX(-50%); 
  }

  .cross-totem {
    position: absolute;
    width: 48px;
    height: 48px;
    background-image: url('Cross.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 0;
  }

  .islam-totem { 
    position: absolute;
    width: 48px;
    height: 48px;
    background-image: url('Islam Moon and Star.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
    bottom: 0;
  }

  .snow-tile {
    background-image: url('SnowTile.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    position: relative;
  }

  .snowy-tree {
    position: absolute;
    width: 64px;
    height: 64px;
    background-image: url('Snowy Tree.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 4;
    transform-origin: bottom center;
    animation: treeFloat 3s ease-in-out infinite;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
  }

  .cactus {
    position: absolute;
    width: 48px;
    height: 48px;
    background-image: url('Cactus.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 3;
    bottom: 0;
  }

  .sand-tile {
    background-image: url('SandTile.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    position: relative;
  }

  .ice-tile {
    background-image: url('IceTile.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    position: relative;
  }

  .carrot-farm-tile {
    width: 100%;
    height: 100%;
    background-image: url('CarrotFarmTile.png');
    background-size: cover;
    background-repeat: no-repeat;
    position: relative;
  }

  .carrot {
    position: absolute;
    width: 32px;
    height: 32px;
    background-image: url('Carrot.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 2;
  }

  @keyframes float {
    0% {
      transform: translateY(100vh) scale(0);
      opacity: 0;
    }
    50% {
      opacity: 0.3;
    }
    100% {
      transform: translateY(-100vh) scale(1);
      opacity: 0;
    }
  }

  @keyframes treeFloat {
    0%, 100% {
      transform: translateX(-50%) rotate(0deg);
    }
    50% {
      transform: translateX(-50%) rotate(2deg);
    }
  }

  @keyframes fireLight {
    0%, 100% {
      filter: brightness(1);
    }
    50% {
      filter: brightness(1.2);
    }
  }
</style>
</head>
<body>
<div id="stats-panel">
  <div class="stat" id="wood-stat">Wood: 0</div>
  <div class="stat" id="stone-stat">Stone: 0</div>
  <div class="stat" id="humans-stat">Humans: 0</div>
  <div class="stat" id="houses-stat">Houses: 0</div>
  <div class="stat" id="cabbage-stat">Cabbage: 0</div>
  <div class="stat" id="docks-stat">Fishing Docks: 0</div>
  <div class="stat" id="fish-stat">Fish: 0</div>
  <div class="stat" id="cabbage-powder-stat">Cabbage Powder: 0</div> 
  <div class="stat" id="iron-stat">Iron: 0</div>
  <div class="stat" id="windmills-stat">Windmills: 0</div>
  <div class="stat" id="furnaces-stat">Blast Furnaces: 0</div>
  <div class="stat" id="charcoal-stat">Charcoal: 0</div>
  <div class="stat" id="sulfur-stat">Sulfur: 0</div>
  <div class="stat" id="gunpowder-stat">Gunpowder: 0</div>
  <div class="stat" id="muskets-stat">Muskets: 0</div>
  <div class="stat" id="cows-stat">Cows: 0</div>
  <div class="stat" id="meat-stat">Meat: 0</div>
  <div class="stat" id="flat-stat">Flats: 0</div>
  <div class="stat" id="carrot-stat">Carrots: 0</div>
</div>
<div class="tile-grid"></div>

<script>let totalLogs = 0;
const LOGS_NEEDED_FOR_HOUSE = 3;
const FARM_SIZE = 3;
const houses = new Set();
let humanCount = 0;
let totalFurnaces = 0;
let totalStone = 0;
const STONE_NEEDED_FOR_FURNACE = 5;
let totalCabbage = 0;
const CABBAGE_GROW_TIME = 10000;
let totalDocks = 0;
const LOGS_NEEDED_FOR_DOCK = 2;
const docks = new Set();
const HUMANS_PER_HOUSE = 2;
let totalFish = 0;
const LOGS_NEEDED_FOR_WINDMILL = 3;
const STONE_NEEDED_FOR_WINDMILL = 1;
let totalCabbagePowder = 0;
const windmills = new Set();
let totalIron = 0;
const STONE_NEEDED_FOR_UPGRADE = 3;
const HUMANS_PER_STONE_HOUSE = 6;
const TREE_REGROW_TIME = 30000;
const furnaces = new Set();
let totalCharcoal = 0;
let totalSulfur = 0;
const WOOD_NEEDED_FOR_CRAFTING_TABLE = 5;
let totalGunpowder = 0;
let totalMuskets = 0;
const WOOD_FOR_MUSKET = 3;
const GUNPOWDER_FOR_MUSKET = 2;
const SPAWN_COW_CHANCE = 0.02;
const COW_MOVE_INTERVAL = 5000;
let totalCows = 0;
let totalMeat = 0;
const ROCK_REGROW_TIME = 30000;
const MINE_YIELD_TIME = 3000;
const WOOD_FOR_MINE = 1;
const STONE_NEEDED_FOR_FLAT = 6;
const WOOD_FOR_TOTEM = 1;
let hasBuiltTotem = false;
let totalCarrots = 0;
const CARROT_GROW_TIME = 10000;
function generatePerlinNoise(width, height, scale) {
  const noise = new Array(width * height);
  const gradients = new Array(width * height);
  for (let i = 0; i < width * height; i++) {
    const angle = Math.random() * 2 * Math.PI;
    gradients[i] = {
      x: Math.cos(angle),
      y: Math.sin(angle)
    };
  }
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let value = 0;
      let amplitude = 1;
      let frequency = 1;
      for (let o = 0; o < 4; o++) {
        const sX = x * frequency / scale;
        const sY = y * frequency / scale;
        const xInt = Math.floor(sX);
        const yInt = Math.floor(sY);
        const xFrac = sX - xInt;
        const yFrac = sY - yInt;
        const g00 = gradients[yInt % height * width + xInt % width];
        const g10 = gradients[yInt % height * width + (xInt + 1) % width];
        const g01 = gradients[(yInt + 1) % height * width + xInt % width];
        const g11 = gradients[(yInt + 1) % height * width + (xInt + 1) % width];
        const dp00 = g00.x * xFrac + g00.y * yFrac;
        const dp10 = g10.x * (xFrac - 1) + g10.y * yFrac;
        const dp01 = g01.x * xFrac + g01.y * (yFrac - 1);
        const dp11 = g11.x * (xFrac - 1) + g11.y * (yFrac - 1);
        const wx = xFrac * xFrac * (3 - 2 * xFrac);
        const wy = yFrac * yFrac * (3 - 2 * yFrac);
        value += amplitude * (dp00 * (1 - wx) * (1 - wy) + dp10 * wx * (1 - wy) + dp01 * (1 - wx) * wy + dp11 * wx * wy);
        amplitude *= 0.5;
        frequency *= 2;
      }
      noise[y * width + x] = (value + 1) / 2;
    }
  }
  return noise;
}
function updateStats() {
  document.getElementById('stats-panel').innerHTML = `
    <div class="stat" id="wood-stat">Wood: ${totalLogs}</div>
    <div class="stat" id="stone-stat">Stone: ${totalStone}</div>
    <div class="stat" id="humans-stat">Humans: ${humanCount}</div>
    <div class="stat" id="houses-stat">Houses: ${houses.size}</div>
    <div class="stat" id="cabbage-stat">Cabbage: ${totalCabbage}</div>
    <div class="stat" id="docks-stat">Fishing Docks: ${docks.size}</div>
    <div class="stat" id="fish-stat">Fish: ${totalFish}</div>
    <div class="stat" id="cabbage-powder-stat">Cabbage Powder: ${totalCabbagePowder}</div>
    <div class="stat" id="iron-stat">Iron: ${totalIron}</div>
    <div class="stat" id="windmills-stat">Windmills: ${windmills.size}</div>
    <div class="stat" id="furnaces-stat">Blast Furnaces: ${furnaces.size}</div>
    <div class="stat" id="charcoal-stat">Charcoal: ${totalCharcoal}</div>
    <div class="stat" id="sulfur-stat">Sulfur: ${totalSulfur}</div>
    <div class="stat" id="gunpowder-stat">Gunpowder: ${totalGunpowder}</div>
    <div class="stat" id="muskets-stat">Muskets: ${totalMuskets}</div>
    <div class="stat" id="cows-stat">Cows: ${totalCows}</div>
    <div class="stat" id="meat-stat">Meat: ${totalMeat}</div>
    <div class="stat" id="flat-stat">Flats: ${document.querySelectorAll('.flat').length}</div>
    <div class="stat" id="carrot-stat">Carrots: ${totalCarrots}</div>
  `;
}
for (let i = 0; i < 50; i++) {
  const dot = document.createElement('div');
  dot.className = 'dot';
  dot.style.left = `${Math.random() * 100}vw`;
  dot.style.animationDelay = `${Math.random() * 20}s`;
  document.body.appendChild(dot);
}
class Human {
  constructor(grid, startX, startY) {
    this.element = document.createElement('div');
    this.isHunter = false;
    this.hasMusket = false;
    this.isKat = Math.random() < 0.05;
    if (this.isHunter) {
      this.element.className = 'hunter';
    } else if (this.isKat) {
      this.element.className = 'kat-human';
    } else {
      this.element.className = 'human';
    }
    document.body.appendChild(this.element);
    this.element.classList.remove('human-swim');
    this.x = startX;
    this.y = startY;
    this.grid = grid;
    this.targetX = startX;
    this.targetY = startY;
    this.speed = 4;
    this.task = 'wander';
    this.hasLog = false;
    this.hasRock = false;
    this.farmingProgress = 0;
    this.hasCabbage = false;
    this.currentCabbage = null;
    this.hasCarrot = false;
    this.currentCarrot = null;
    this.buildingDock = false;
    this.fishingProgress = 0;
    this.hasFish = false;
    this.currentFish = null;
    this.hasCabbagePowder = false;
    this.currentCabbagePowder = null;
    this.hasIron = false;
    this.currentIron = null;
    this.hasSulfur = false;
    this.currentSulfur = null;
    this.hasGunpowder = false;
    this.currentGunpowder = null;
    this.hasMusket = false;
    this.digging = false;
    this.currentMine = null;
    this.updatePosition();
    humanCount++;
    updateStats();
    this.think();
  }
  updatePosition() {
    const maxX = this.grid.offsetWidth - 32;
    const maxY = this.grid.offsetHeight - 32;
    this.x = Math.max(0, Math.min(this.x, maxX));
    this.y = Math.max(0, Math.min(this.y, maxY));
    this.element.style.left = `${this.x}px`;
    this.element.style.top = `${this.y}px`;

    const tileSize = 64;
    const col = Math.floor(this.x / tileSize);
    const row = Math.floor(this.y / tileSize);
    const tileGrid = document.querySelector('.tile-grid');
    const gridCols = getComputedStyle(tileGrid).gridTemplateColumns.split(' ').length;
    const tile = tileGrid.children[row * gridCols + col];

    if (tile && (tile.classList.contains('water-tile') || tile.classList.contains('ice-tile'))) {
        if (this.isKat) {
            this.element.className = 'kat-human-swim';
        } else {
            this.element.classList.add('human-swim');
        }
    } else {
        if (this.isKat) {
            this.element.className = 'kat-human';
        } else {
            this.element.classList.remove('human-swim');
        }
    }
  }
  moveTowards(targetX, targetY) {
    const dx = targetX - this.x;
    const dy = targetY - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance > this.speed) {
      this.x += dx / distance * this.speed;
      this.y += dy / distance * this.speed;
      this.updatePosition();
      return false;
    }
    return true;
  }
  findNearestTree() {
    const trees = document.querySelectorAll('.tree, .snowy-tree');
    let nearest = null;
    let minDist = Infinity;
    trees.forEach(tree => {
      const rect = tree.getBoundingClientRect();
      const dx = rect.left - this.x;
      const dy = rect.top - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < minDist) {
        minDist = dist;
        nearest = tree;
      }
    });
    return nearest;
  }
  findBuildingLocation() {
    const buildings = [...houses, this.findCampfire()].filter(b => b);
    const randomBuilding = buildings[Math.floor(Math.random() * buildings.length)];
    if (!randomBuilding) return null;
    const buildingRect = randomBuilding.getBoundingClientRect();
    let attempts = 0;
    while (attempts < 10) {
      const angle = Math.random() * Math.PI * 2;
      const distance = 100 + Math.random() * 100;
      const x = buildingRect.left + Math.cos(angle) * distance;
      const y = buildingRect.top + Math.sin(angle) * distance;
      const tileSize = 64;
      const col = Math.floor(x / tileSize);
      const row = Math.floor(y / tileSize);
      const tileGrid = document.querySelector('.tile-grid');
      const gridCols = getComputedStyle(tileGrid).gridTemplateColumns.split(' ').length;
      const tile = tileGrid.children[row * gridCols + col];
      if (tile && !tile.querySelector('.tree, .rock, .house, .campfire, .farm-tile, .farm-tile-cabbage, .windmill, .fishing-dock, .iron-deposit, .crafting-table, .flat, .cactus, .cross-totem, .islam-totem')) {
        if (this.buildingDock) {
          if (tile.classList.contains('water-tile')) {
            return {
              x,
              y
            };
          }
        } else {
          if (!tile.classList.contains('water-tile')) {
            return {
              x,
              y
            };
          }
        }
      }
      attempts++;
    }
    return null;
  }
  createHouse(x, y) {
    const tileSize = 64;
    const col = Math.floor(x / tileSize);
    const row = Math.floor(y / tileSize);
    const tileGrid = document.querySelector('.tile-grid');
    const gridCols = getComputedStyle(tileGrid).gridTemplateColumns.split(' ').length;
    const tile = tileGrid.children[row * gridCols + col];
    if (tile) {
      const house = document.createElement('div');
      house.className = 'house';
      tile.appendChild(house);
      houses.add(house);
      updateStats();
      return house;
    }
    return null;
  }
  findCampfire() {
    return document.querySelector('.campfire');
  }
  createLog(x, y) {
    const log = document.createElement('div');
    log.className = 'log';
    log.style.left = `${x}px`;
    log.style.top = `${y}px`;
    document.body.appendChild(log);
    return log;
  }
  findNearestRock() {
    const rocks = document.querySelectorAll('.rock');
    let nearest = null;
    let minDist = Infinity;
    rocks.forEach(rock => {
      const rect = rock.getBoundingClientRect();
      const dx = rect.left - this.x;
      const dy = rect.top - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < minDist) {
        minDist = dist;
        nearest = rock;
      }
    });
    return nearest;
  }
  createRockItem(x, y) {
    const rockItem = document.createElement('div');
    rockItem.className = 'rock-item';
    rockItem.style.left = `${x}px`;
    rockItem.style.top = `${y}px`;
    document.body.appendChild(rockItem);
    return rockItem;
  }
  findFarmLocation() {
    const tileGrid = this.grid;
    const tiles = Array.from(tileGrid.children);
    const gridCols = getComputedStyle(tileGrid).gridTemplateColumns.split(' ').length;
    for (let i = 0; i < tiles.length - FARM_SIZE * gridCols; i++) {
      let valid = true;
      const row = Math.floor(i / gridCols);
      const col = i % gridCols;
      if (col > gridCols - FARM_SIZE) continue;
      for (let dy = 0; dy < FARM_SIZE; dy++) {
        for (let dx = 0; dx < FARM_SIZE; dx++) {
          const tile = tiles[i + dy * gridCols + dx];
          if (!tile || tile.querySelector('.tree, .rock, .house, .campfire') || tile.firstChild?.classList.contains('farm-tile') || tile.classList.contains('water-tile') || tile.classList.contains('ice-tile')) {
            valid = false;
            break;
          }
        }
        if (!valid) break;
      }
      if (valid) {
        const tile = tiles[i];
        const rect = tile.getBoundingClientRect();
        return {
          x: rect.left,
          y: rect.top,
          tileIndex: i,
          gridCols
        };
      }
    }
    return null;
  }
  createFarmPlot(location) {
    const tiles = Array.from(this.grid.children);
    const {
      tileIndex,
      gridCols
    } = location;
    for (let dy = 0; dy < FARM_SIZE; dy++) {
      for (let dx = 0; dx < FARM_SIZE; dx++) {
        const tile = tiles[tileIndex + dy * gridCols + dx];
        if (tile) {
          tile.firstChild?.remove();
          const isCarrot = Math.random() < 0.5;
          const farmTile = document.createElement('div');
          farmTile.className = isCarrot ? 'farm-tile' : 'farm-tile';
          tile.appendChild(farmTile);
          setTimeout(() => {
            if (farmTile.parentNode) {
              if (isCarrot) {
                farmTile.className = 'carrot-farm-tile';
                const carrot = document.createElement('div');
                carrot.className = 'carrot';
                farmTile.appendChild(carrot);
              } else {
                farmTile.className = 'farm-tile-cabbage';
                const cabbage = document.createElement('div');
                cabbage.className = 'cabbage';
                farmTile.appendChild(cabbage);
              }
            }
          }, isCarrot ? CARROT_GROW_TIME : CABBAGE_GROW_TIME);
        }
      }
    }
  }
  createCabbage(x, y) {
    const cabbage = document.createElement('div');
    cabbage.className = 'cabbage';
    cabbage.style.left = `${x}px`;
    cabbage.style.top = `${y}px`;
    document.body.appendChild(cabbage);
    return cabbage;
  }
  createCarrot(x, y) {
    const carrot = document.createElement('div');
    carrot.className = 'carrot';
    carrot.style.left = `${x}px`;
    carrot.style.top = `${y}px`;
    document.body.appendChild(carrot);
    return carrot;
  }
  async think() {
    while (true) {
      if (this.task === 'wander') {
        const items = document.querySelectorAll('.log, .rock-item, .cabbage, .carrot, .fish, .cabbage-powder, .iron-item, .sulfur-item, .charcoal, .gunpowder, .musket, .raw-beef');
        const nearbyItem = Array.from(items).find(item => {
          const rect = item.getBoundingClientRect();
          const dx = rect.left - this.x;
          const dy = rect.top - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          return dist < 50;
        });
        if (nearbyItem) {
          const rect = nearbyItem.getBoundingClientRect();
          while (!this.moveTowards(rect.left, rect.top)) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          if (nearbyItem.classList.contains('log')) {
            nearbyItem.remove();
            totalLogs++;
          } else if (nearbyItem.classList.contains('rock-item')) {
            nearbyItem.remove();
            totalStone++;
          } else if (nearbyItem.classList.contains('cabbage')) {
            nearbyItem.remove();
            totalCabbage++;
          } else if (nearbyItem.classList.contains('carrot')) {
            nearbyItem.remove();
            totalCarrots++;
          } else if (nearbyItem.classList.contains('fish')) {
            nearbyItem.remove();
            totalFish++;
          } else if (nearbyItem.classList.contains('cabbage-powder')) {
            nearbyItem.remove();
            totalCabbagePowder++;
          } else if (nearbyItem.classList.contains('iron-item')) {
            nearbyItem.remove();
            totalIron++;
          } else if (nearbyItem.classList.contains('sulfur-item')) {
            nearbyItem.remove();
            totalSulfur++;
          } else if (nearbyItem.classList.contains('charcoal')) {
            nearbyItem.remove();
            totalCharcoal++;
          } else if (nearbyItem.classList.contains('gunpowder')) {
            nearbyItem.remove();
            totalGunpowder++;
          } else if (nearbyItem.classList.contains('musket')) {
            nearbyItem.remove();
            totalMuskets++;
            this.hasMusket = true;
            this.element.className = 'hunter';
            this.isHunter = true;
          } else if (nearbyItem.classList.contains('raw-beef')) {
            nearbyItem.remove();
            totalMeat++;
          }
          updateStats();
        }
        if (!hasBuiltTotem && totalLogs >= WOOD_FOR_TOTEM && document.querySelectorAll('.cross-totem, .islam-totem').length === 0) {
          const campfire = this.findCampfire();
          const campfireRect = campfire.getBoundingClientRect();
          const tileSize = 64;
          const col = Math.floor(campfireRect.left / tileSize);
          const row = Math.floor(campfireRect.top / tileSize);
          const tileGrid = document.querySelector('.tile-grid');
          const gridCols = getComputedStyle(tileGrid).gridTemplateColumns.split(' ').length;
          const campfireTile = tileGrid.children[row * gridCols + col];
          if (campfireTile.classList.contains('sand-tile')) {
            this.task = Math.random() < 0.75 ? 'buildIslamTotem' : 'buildCrossTotem';
          } else if (campfireTile.classList.contains('snow-tile') || campfireTile.classList.contains('tile')) {
            this.task = Math.random() < 0.75 ? 'buildCrossTotem' : 'buildIslamTotem';
          }
        } else {
          this.targetX = Math.random() * this.grid.offsetWidth;
          this.targetY = Math.random() * this.grid.offsetHeight;
          while (!this.moveTowards(this.targetX, this.targetY)) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          if (!hasBuiltTotem && totalLogs >= WOOD_FOR_TOTEM) {
            const campfire = this.findCampfire();
            const campfireRect = campfire.getBoundingClientRect();
            const tileSize = 64;
            const col = Math.floor(campfireRect.left / tileSize);
            const row = Math.floor(campfireRect.top / tileSize);
            const tileGrid = document.querySelector('.tile-grid');
            const gridCols = getComputedStyle(tileGrid).gridTemplateColumns.split(' ').length;
            const campfireTile = tileGrid.children[row * gridCols + col];
            if (campfireTile.classList.contains('sand-tile')) {
              this.task = Math.random() < 0.75 ? 'buildIslamTotem' : 'buildCrossTotem';
            } else if (campfireTile.classList.contains('snow-tile') || campfireTile.classList.contains('tile')) {
              this.task = Math.random() < 0.75 ? 'buildCrossTotem' : 'buildIslamTotem';
            }
          } else if (houses.size >= 7) {
            const tasks = ['cutTree', 'mineRock', 'farm', 'fish', 'makeCabbagePowder', 'mineIron', 'mineSulfur', 'makeGunpowder', 'makeMusket', 'mine'];
            if (!hasBuiltTotem && totalLogs >= WOOD_FOR_TOTEM) {
              const campfire = this.findCampfire();
              const campfireRect = campfire.getBoundingClientRect();
              const tileSize = 64;
              const col = Math.floor(campfireRect.left / tileSize);
              const row = Math.floor(campfireRect.top / tileSize);
              const tileGrid = document.querySelector('.tile-grid');
              const gridCols = getComputedStyle(tileGrid).gridTemplateColumns.split(' ').length;
              const campfireTile = tileGrid.children[row * gridCols + col];
              if (campfireTile.classList.contains('sand-tile')) {
                if (Math.random() < 0.75) {
                  tasks.push('buildIslamTotem');
                } else {
                  tasks.push('buildCrossTotem');
                }
              } else if (campfireTile.classList.contains('snow-tile') || campfireTile.classList.contains('tile')) {
                if (Math.random() < 0.75) {
                  tasks.push('buildCrossTotem');
                } else {
                  tasks.push('buildIslamTotem');
                }
              }
            }
            if (document.querySelectorAll('.crafting-table').length === 0 && totalLogs >= WOOD_NEEDED_FOR_CRAFTING_TABLE) {
              tasks.push('buildCraftingTable');
              tasks.push('buildCraftingTable');
            }
            if (furnaces.size === 0 && totalStone >= STONE_NEEDED_FOR_FURNACE) {
              tasks.push('buildFurnace');
            } else {
              if (this.isHunter) {
                tasks.push('huntCow');
              }
              if (furnaces.size === 0 && totalStone >= STONE_NEEDED_FOR_FURNACE) {
                tasks.push('buildFurnace');
              }
              if (totalLogs >= LOGS_NEEDED_FOR_HOUSE) {
                tasks.push('buildHouse');
              }
              if (totalLogs >= LOGS_NEEDED_FOR_DOCK) {
                tasks.push('buildDock');
              }
              if (totalLogs >= LOGS_NEEDED_FOR_WINDMILL && totalStone >= STONE_NEEDED_FOR_WINDMILL) {
                tasks.push('buildWindmill');
              }
              if (totalStone >= STONE_NEEDED_FOR_UPGRADE) {
                tasks.push('upgradeHouse');
              }
              if (totalLogs > 0 && furnaces.size > 0) {
                tasks.push('makeCharcoal');
              }
              if (totalLogs >= WOOD_NEEDED_FOR_CRAFTING_TABLE) {
                tasks.push('buildCraftingTable');
              }
              if (totalStone >= STONE_NEEDED_FOR_FLAT) {
                tasks.push('buildFlat');
              }
              const campfire = this.findCampfire();
              const campfireRect = campfire.getBoundingClientRect();
              const tileSize = 64;
              const col = Math.floor(campfireRect.left / tileSize);
              const row = Math.floor(campfireRect.top / tileSize);
              const tileGrid = document.querySelector('.tile-grid');
              const gridCols = getComputedStyle(tileGrid).gridTemplateColumns.split(' ').length;
              const campfireTile = tileGrid.children[row * gridCols + col];
              if (campfireTile.classList.contains('sand-tile')) {
                if (Math.random() < 0.75) {
                  tasks.push('buildIslamTotem');
                  tasks.push('buildIslamTotem');
                } else {
                  tasks.push('buildCrossTotem');
                }
              } else if (campfireTile.classList.contains('snow-tile') || campfireTile.classList.contains('tile')) {
                if (Math.random() < 0.75) {
                  tasks.push('buildCrossTotem');
                  tasks.push('buildCrossTotem');
                } else {
                  tasks.push('buildIslamTotem');
                }
              }
              this.task = tasks[Math.floor(Math.random() * tasks.length)];
            }
          } else {
            if (document.querySelectorAll('.crafting-table').length === 0 && totalLogs >= WOOD_NEEDED_FOR_CRAFTING_TABLE) {
              this.task = 'buildCraftingTable';
            } else if (furnaces.size === 0 && totalStone >= STONE_NEEDED_FOR_FURNACE) {
              this.task = 'buildFurnace';
            } else if (totalLogs >= LOGS_NEEDED_FOR_HOUSE) {
              this.task = 'buildHouse';
            } else if (totalStone >= STONE_NEEDED_FOR_UPGRADE) {
              const woodHouses = Array.from(houses).filter(h => !h.classList.contains('stone-house'));
              if (woodHouses.length > 0) {
                this.task = 'upgradeHouse';
              } else {
                this.task = 'cutTree';
              }
            } else {
              this.task = 'cutTree';
            }
          }
        }
        await new Promise(resolve => setTimeout(resolve, 2000));
      } else if (this.task === 'cutTree') {
        const tree = this.findNearestTree();
        if (tree) {
          const rect = tree.getBoundingClientRect();
          while (!this.moveTowards(rect.left, rect.top)) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          await new Promise(resolve => setTimeout(resolve, 2000));
          const treePos = {
            x: rect.left,
            y: rect.top
          };
          tree.remove();
          const tileSize = 64;
          const col = Math.floor(rect.left / tileSize);
          const row = Math.floor(rect.top / tileSize);
          const tile = this.grid.children[row * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + col];
          setTimeout(() => {
            if (tile && !tile.querySelector('.tree, .rock, .house, .campfire, .farm-tile, .farm-tile-cabbage, .windmill, .fishing-dock, .iron-deposit')) {
              const newTree = document.createElement('div');
              newTree.className = 'tree';
              newTree.style.animationDelay = `${Math.random() * 2}s`;
              tile.appendChild(newTree);
            }
          }, TREE_REGROW_TIME);
          this.currentLog = this.createLog(treePos.x, treePos.y);
          this.hasLog = true;
          this.task = 'deliverLog';
        } else {
          this.task = 'wander';
        }
      } else if (this.task === 'deliverLog') {
        const campfire = this.findCampfire();
        if (campfire && this.currentLog) {
          const rect = campfire.getBoundingClientRect();
          while (!this.moveTowards(rect.left, rect.top)) {
            this.currentLog.style.left = `${this.x}px`;
            this.currentLog.style.top = `${this.y}px`;
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          this.currentLog.remove();
          this.currentLog = null;
          this.hasLog = false;
          totalLogs++;
          updateStats();
          this.task = 'wander';
        } else {
          this.task = 'wander';
        }
      } else if (this.task === 'mineRock') {
        const rock = this.findNearestRock();
        if (rock) {
          const rect = rock.getBoundingClientRect();
          while (!this.moveTowards(rect.left, rect.top)) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          await new Promise(resolve => setTimeout(resolve, 2000));
          const rockPos = {
            x: rect.left,
            y: rect.top
          };
          rock.remove();
          this.currentRockItem = this.createRockItem(rockPos.x, rockPos.y);
          this.hasRock = true;
          this.task = 'deliverRock';
        } else {
          this.task = 'wander';
        }
      } else if (this.task === 'deliverRock') {
        const campfire = this.findCampfire();
        if (campfire && this.currentRockItem) {
          const rect = campfire.getBoundingClientRect();
          while (!this.moveTowards(rect.left, rect.top)) {
            this.currentRockItem.style.left = `${this.x}px`;
            this.currentRockItem.style.top = `${this.y}px`;
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          this.currentRockItem.remove();
          this.currentRockItem = null;
          this.hasRock = false;
          totalStone++;
          updateStats();
          this.task = 'wander';
        } else {
          this.task = 'wander';
        }
      } else if (this.task === 'buildHouse') {
        if (totalLogs >= LOGS_NEEDED_FOR_HOUSE) {
          const buildLocation = this.findBuildingLocation();
          if (buildLocation) {
            while (!this.moveTowards(buildLocation.x, buildLocation.y)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 3000));
            if (totalLogs >= LOGS_NEEDED_FOR_HOUSE) {
              this.createHouse(buildLocation.x, buildLocation.y);
              totalLogs -= LOGS_NEEDED_FOR_HOUSE;
              updateStats();
              const availableSpace = houses.size * HUMANS_PER_HOUSE - humanCount;
              for (let i = 0; i < Math.min(2, availableSpace); i++) {
                new Human(this.grid, buildLocation.x, buildLocation.y);
              }
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'buildDock') {
        this.buildingDock = true;
        if (totalLogs >= LOGS_NEEDED_FOR_DOCK) {
          const buildLocation = this.findBuildingLocation();
          if (buildLocation) {
            while (!this.moveTowards(buildLocation.x, buildLocation.y)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 3000));
            if (totalLogs >= LOGS_NEEDED_FOR_DOCK) {
              const dock = document.createElement('div');
              dock.className = 'fishing-dock';
              const tile = this.grid.children[Math.floor(buildLocation.y / 64) * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + Math.floor(buildLocation.x / 64)];
              if (tile) {
                tile.appendChild(dock);
                docks.add(dock);
                totalLogs -= LOGS_NEEDED_FOR_DOCK;
                updateStats();
              }
            }
          }
        }
        this.buildingDock = false;
        this.task = 'wander';
      } else if (this.task === 'farm') {
        const farmLocation = this.findFarmLocation();
        if (farmLocation) {
          const tiles = Array.from(this.grid.children);
          const nearbyTiles = tiles.filter(tile => {
            const rect = tile.getBoundingClientRect();
            const dx = rect.left - this.x;
            const dy = rect.top - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < 100 && (tile.querySelector('.cabbage') || tile.querySelector('.carrot'));
          });
          if (nearbyTiles.length > 0) {
            const targetTile = nearbyTiles[0];
            const rect = targetTile.getBoundingClientRect();
            while (!this.moveTowards(rect.left, rect.top)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            const crop = targetTile.querySelector('.cabbage, .carrot');
            if (crop) {
              const isCabbage = crop.classList.contains('cabbage');
              crop.remove();
              if (isCabbage) {
                this.currentCabbage = this.createCabbage(rect.left, rect.top);
                this.hasCabbage = true;
                targetTile.firstChild.className = 'farm-tile';
              } else {
                this.currentCarrot = this.createCarrot(rect.left, rect.top);
                this.hasCarrot = true;
                targetTile.firstChild.className = 'farm-tile';
              }
              const campfire = this.findCampfire();
              if (campfire) {
                const campfireRect = campfire.getBoundingClientRect();
                while (!this.moveTowards(campfireRect.left, campfireRect.top)) {
                  if (isCabbage) {
                    this.currentCabbage.style.left = `${this.x}px`;
                    this.currentCabbage.style.top = `${this.y}px`;
                  } else {
                    this.currentCarrot.style.left = `${this.x}px`;
                    this.currentCarrot.style.top = `${this.y}px`;
                  }
                  await new Promise(resolve => setTimeout(resolve, 50));
                }
                if (isCabbage && this.currentCabbage) {
                  this.currentCabbage.remove();
                  this.currentCabbage = null;
                  this.hasCabbage = false;
                  totalCabbage++;
                } else if (!isCabbage && this.currentCarrot) {
                  this.currentCarrot.remove();
                  this.currentCarrot = null;
                  this.hasCarrot = false;
                  totalCarrots++;
                }
                updateStats();
              }
              setTimeout(() => {
                if (targetTile.firstChild) {
                  if (isCabbage) {
                    targetTile.firstChild.className = 'farm-tile-cabbage';
                    const newCabbage = document.createElement('div');
                    newCabbage.className = 'cabbage';
                    targetTile.firstChild.appendChild(newCabbage);
                  } else {
                    targetTile.firstChild.className = 'carrot-farm-tile';
                    const newCarrot = document.createElement('div');
                    newCarrot.className = 'carrot';
                    targetTile.firstChild.appendChild(newCarrot);
                  }
                }
              }, isCabbage ? CABBAGE_GROW_TIME : CARROT_GROW_TIME);
            }
          }
          while (!this.moveTowards(farmLocation.x, farmLocation.y)) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          this.farmingProgress += 0.1;
          if (this.farmingProgress >= 1) {
            this.farmingProgress = 0;
            this.createFarmPlot(farmLocation);
            this.task = 'wander';
          }
          await new Promise(resolve => setTimeout(resolve, 1000));
        } else {
          this.task = 'wander';
        }
      } else if (this.task === 'fish') {
        const allDocks = Array.from(docks);
        if (allDocks.length > 0) {
          const randomDock = allDocks[Math.floor(Math.random() * allDocks.length)];
          const rect = randomDock.getBoundingClientRect();
          while (!this.moveTowards(rect.left, rect.top)) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          this.fishingProgress += 0.1;
          if (this.fishingProgress >= 1) {
            this.fishingProgress = 0;
            const fish = document.createElement('div');
            fish.className = 'fish';
            fish.style.left = `${this.x}px`;
            fish.style.top = `${this.y}px`;
            document.body.appendChild(fish);
            this.currentFish = fish;
            this.hasFish = true;
            const campfire = this.findCampfire();
            if (campfire) {
              const campfireRect = campfire.getBoundingClientRect();
              while (!this.moveTowards(campfireRect.left, campfireRect.top)) {
                this.currentFish.style.left = `${this.x}px`;
                this.currentFish.style.top = `${this.y}px`;
                await new Promise(resolve => setTimeout(resolve, 50));
              }
              if (this.currentFish) {
                this.currentFish.remove();
                this.currentFish = null;
                this.hasFish = false;
                totalFish++;
                updateStats();
              }
            }
            this.task = 'wander';
          }
          await new Promise(resolve => setTimeout(resolve, 1000));
        } else {
          this.task = 'wander';
        }
      } else if (this.task === 'buildWindmill') {
        if (totalLogs >= LOGS_NEEDED_FOR_WINDMILL && totalStone >= STONE_NEEDED_FOR_WINDMILL) {
          const buildLocation = this.findBuildingLocation();
          if (buildLocation) {
            while (!this.moveTowards(buildLocation.x, buildLocation.y)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 3000));
            if (totalLogs >= LOGS_NEEDED_FOR_WINDMILL && totalStone >= STONE_NEEDED_FOR_WINDMILL) {
              const windmill = document.createElement('div');
              windmill.className = 'windmill';
              const tile = this.grid.children[Math.floor(buildLocation.y / 64) * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + Math.floor(buildLocation.x / 64)];
              if (tile) {
                tile.appendChild(windmill);
                windmills.add(windmill);
                totalLogs -= LOGS_NEEDED_FOR_WINDMILL;
                totalStone -= STONE_NEEDED_FOR_WINDMILL;
                updateStats();
              }
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'makeCabbagePowder') {
        if (totalCabbage > 0) {
          const windmill = Array.from(windmills)[Math.floor(Math.random() * windmills.size)];
          if (windmill) {
            const rect = windmill.getBoundingClientRect();
            while (!this.moveTowards(rect.left, rect.top)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            totalCabbage--;
            this.currentCabbagePowder = document.createElement('div');
            this.currentCabbagePowder.className = 'cabbage-powder';
            this.currentCabbagePowder.style.left = `${this.x}px`;
            this.currentCabbagePowder.style.top = `${this.y}px`;
            document.body.appendChild(this.currentCabbagePowder);
            this.hasCabbagePowder = true;
            const campfire = this.findCampfire();
            if (campfire) {
              const campfireRect = campfire.getBoundingClientRect();
              while (!this.moveTowards(campfireRect.left, campfireRect.top)) {
                this.currentCabbagePowder.style.left = `${this.x}px`;
                this.currentCabbagePowder.style.top = `${this.y}px`;
                await new Promise(resolve => setTimeout(resolve, 50));
              }
              if (this.currentCabbagePowder) {
                this.currentCabbagePowder.remove();
                this.currentCabbagePowder = null;
                this.hasCabbagePowder = false;
                totalCabbagePowder++;
                updateStats();
              }
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'mineIron') {
        const ironDeposits = Array.from(document.querySelectorAll('.iron-deposit'));
        if (ironDeposits.length > 0) {
          const deposit = ironDeposits[Math.floor(Math.random() * ironDeposits.length)];
          const rect = deposit.getBoundingClientRect();
          while (!this.moveTowards(rect.left, rect.top)) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          await new Promise(resolve => setTimeout(resolve, 2000));
          deposit.remove();
          const tileSize = 64;
          const col = Math.floor(rect.left / tileSize);
          const row = Math.floor(rect.top / tileSize);
          const tile = this.grid.children[row * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + col];
          setTimeout(() => {
            if (tile && !tile.querySelector('.tree, .rock, .house, .campfire, .farm-tile, .farm-tile-cabbage, .windmill, .fishing-dock, .iron-deposit')) {
              const newIronDeposit = document.createElement('div');
              newIronDeposit.className = 'iron-deposit';
              tile.appendChild(newIronDeposit);
            }
          }, ROCK_REGROW_TIME);
          this.currentIron = document.createElement('div');
          this.currentIron.className = 'iron-item';
          this.currentIron.style.left = `${this.x}px`;
          this.currentIron.style.top = `${this.y}px`;
          document.body.appendChild(this.currentIron);
          this.hasIron = true;
          const campfire = this.findCampfire();
          if (campfire) {
            const campfireRect = campfire.getBoundingClientRect();
            while (!this.moveTowards(campfireRect.left, campfireRect.top)) {
              this.currentIron.style.left = `${this.x}px`;
              this.currentIron.style.top = `${this.y}px`;
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            if (this.currentIron) {
              this.currentIron.remove();
              this.currentIron = null;
              this.hasIron = false;
              totalIron++;
              updateStats();
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'mineSulfur') {
        const sulfurDeposits = Array.from(document.querySelectorAll('.sulfur-deposit'));
        if (sulfurDeposits.length > 0) {
          const deposit = sulfurDeposits[Math.floor(Math.random() * sulfurDeposits.length)];
          const rect = deposit.getBoundingClientRect();
          while (!this.moveTowards(rect.left, rect.top)) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          await new Promise(resolve => setTimeout(resolve, 2000));
          deposit.remove();
          const tileSize = 64;
          const col = Math.floor(rect.left / tileSize);
          const row = Math.floor(rect.top / tileSize);
          const tile = this.grid.children[row * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + col];
          setTimeout(() => {
            if (tile && !tile.querySelector('.tree, .rock, .house, .campfire, .farm-tile, .farm-tile-cabbage, .windmill, .fishing-dock, .iron-deposit, .sulfur-deposit')) {
              const newSulfurDeposit = document.createElement('div');
              newSulfurDeposit.className = 'sulfur-deposit';
              tile.appendChild(newSulfurDeposit);
            }
          }, ROCK_REGROW_TIME);
          this.currentSulfur = document.createElement('div');
          this.currentSulfur.className = 'sulfur-item';
          this.currentSulfur.style.left = `${this.x}px`;
          this.currentSulfur.style.top = `${this.y}px`;
          document.body.appendChild(this.currentSulfur);
          this.hasSulfur = true;
          const campfire = this.findCampfire();
          if (campfire) {
            const campfireRect = campfire.getBoundingClientRect();
            while (!this.moveTowards(campfireRect.left, campfireRect.top)) {
              this.currentSulfur.style.left = `${this.x}px`;
              this.currentSulfur.style.top = `${this.y}px`;
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            if (this.currentSulfur) {
              this.currentSulfur.remove();
              this.currentSulfur = null;
              this.hasSulfur = false;
              totalSulfur++;
              updateStats();
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'buildFurnace') {
        if (totalStone >= STONE_NEEDED_FOR_FURNACE) {
          const buildLocation = this.findBuildingLocation();
          if (buildLocation) {
            while (!this.moveTowards(buildLocation.x, buildLocation.y)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 3000));
            if (totalStone >= STONE_NEEDED_FOR_FURNACE) {
              const furnace = document.createElement('div');
              furnace.className = 'blast-furnace';
              const tile = this.grid.children[Math.floor(buildLocation.y / 64) * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + Math.floor(buildLocation.x / 64)];
              if (tile) {
                tile.appendChild(furnace);
                furnaces.add(furnace);
                totalStone -= STONE_NEEDED_FOR_FURNACE;
                updateStats();
              }
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'upgradeHouse') {
        if (totalStone >= STONE_NEEDED_FOR_UPGRADE) {
          const woodHouses = Array.from(houses).filter(h => !h.classList.contains('stone-house'));
          if (woodHouses.length > 0) {
            const targetHouse = woodHouses[0];
            const rect = targetHouse.getBoundingClientRect();
            while (!this.moveTowards(rect.left, rect.top)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 3000));
            if (totalStone >= STONE_NEEDED_FOR_UPGRADE) {
              targetHouse.className = 'stone-house';
              totalStone -= STONE_NEEDED_FOR_UPGRADE;
              updateStats();
              const currentHumans = Array.from(document.querySelectorAll('.human')).length;
              const availableSpace = HUMANS_PER_STONE_HOUSE - 2;
              for (let i = 0; i < availableSpace; i++) {
                new Human(this.grid, rect.left, rect.top);
              }
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'makeCharcoal') {
        if (totalLogs > 0 && furnaces.size > 0) {
          const furnace = Array.from(furnaces)[Math.floor(Math.random() * furnaces.size)];
          if (furnace) {
            const rect = furnace.getBoundingClientRect();
            while (!this.moveTowards(rect.left, rect.top)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
            totalLogs--;
            const charcoal = document.createElement('div');
            charcoal.className = 'charcoal';
            charcoal.style.left = `${this.x}px`;
            charcoal.style.top = `${this.y}px`;
            document.body.appendChild(charcoal);
            const campfire = this.findCampfire();
            if (campfire) {
              const campfireRect = campfire.getBoundingClientRect();
              while (!this.moveTowards(campfireRect.left, campfireRect.top)) {
                charcoal.style.left = `${this.x}px`;
                charcoal.style.top = `${this.y}px`;
                await new Promise(resolve => setTimeout(resolve, 50));
              }
              charcoal.remove();
              totalCharcoal++;
              updateStats();
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'buildCraftingTable') {
        if (totalLogs >= WOOD_NEEDED_FOR_CRAFTING_TABLE && document.querySelectorAll('.crafting-table').length === 0) {
          const buildLocation = this.findBuildingLocation();
          if (buildLocation) {
            while (!this.moveTowards(buildLocation.x, buildLocation.y)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 3000));
            if (totalLogs >= WOOD_NEEDED_FOR_CRAFTING_TABLE && document.querySelectorAll('.crafting-table').length === 0) {
              const craftingTable = document.createElement('div');
              craftingTable.className = 'crafting-table';
              const tile = this.grid.children[Math.floor(buildLocation.y / 64) * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + Math.floor(buildLocation.x / 64)];
              if (tile) {
                tile.appendChild(craftingTable);
                totalLogs -= WOOD_NEEDED_FOR_CRAFTING_TABLE;
                updateStats();
              }
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'makeGunpowder') {
        if (totalCharcoal > 0 && totalSulfur > 0) {
          const craftingTables = Array.from(document.querySelectorAll('.crafting-table'));
          if (craftingTables.length > 0) {
            const table = craftingTables[Math.floor(Math.random() * craftingTables.length)];
            const rect = table.getBoundingClientRect();
            while (!this.moveTowards(rect.left, rect.top)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
            totalCharcoal--;
            totalSulfur--;
            this.currentGunpowder = document.createElement('div');
            this.currentGunpowder.className = 'gunpowder';
            this.currentGunpowder.style.left = `${this.x}px`;
            this.currentGunpowder.style.top = `${this.y}px`;
            document.body.appendChild(this.currentGunpowder);
            this.hasGunpowder = true;
            const campfire = this.findCampfire();
            if (campfire) {
              const campfireRect = campfire.getBoundingClientRect();
              while (!this.moveTowards(campfireRect.left, campfireRect.top)) {
                this.currentGunpowder.style.left = `${this.x}px`;
                this.currentGunpowder.style.top = `${this.y}px`;
                await new Promise(resolve => setTimeout(resolve, 50));
              }
              if (this.currentGunpowder) {
                this.currentGunpowder.remove();
                this.currentGunpowder = null;
                this.hasGunpowder = false;
                totalGunpowder++;
                updateStats();
              }
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'makeMusket') {
        if (totalLogs >= WOOD_FOR_MUSKET && totalGunpowder >= GUNPOWDER_FOR_MUSKET) {
          const craftingTables = Array.from(document.querySelectorAll('.crafting-table'));
          if (craftingTables.length > 0) {
            const table = craftingTables[Math.floor(Math.random() * craftingTables.length)];
            const rect = table.getBoundingClientRect();
            while (!this.moveTowards(rect.left, rect.top)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
            totalLogs -= WOOD_FOR_MUSKET;
            totalGunpowder -= GUNPOWDER_FOR_MUSKET;
            totalMuskets++;
            this.hasMusket = true;
            this.isHunter = true;
            this.element.className = 'hunter';
            updateStats();
          }
        }
        this.task = 'wander';
      } else if (this.task === 'mine') {
        if (totalLogs < WOOD_FOR_MINE) {
          this.task = 'wander';
          return;
        }
        const buildLocation = this.findBuildingLocation();
        if (buildLocation && !this.digging) {
          while (!this.moveTowards(buildLocation.x, buildLocation.y)) {
            await new Promise(resolve => setTimeout(resolve, 50));
          }
          await new Promise(resolve => setTimeout(resolve, 3000));
          if (totalLogs >= WOOD_FOR_MINE) {
            totalLogs -= WOOD_FOR_MINE;
            updateStats();
            const mine = document.createElement('div');
            mine.className = 'mine';
            const tileSize = 64;
            const col = Math.floor(buildLocation.x / tileSize);
            const row = Math.floor(buildLocation.y / tileSize);
            const tile = this.grid.children[row * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + col];
            if (tile) {
              tile.appendChild(mine);
              this.digging = true;
              this.currentMine = mine;
              await new Promise(resolve => setTimeout(resolve, MINE_YIELD_TIME));
              const resource = Math.random();
              if (resource < 0.4) {
                this.currentRockItem = this.createRockItem(this.x, this.y);
                this.hasRock = true;
                this.task = 'deliverRock';
              } else if (resource < 0.7) {
                this.currentIron = document.createElement('div');
                this.currentIron.className = 'iron-item';
                this.currentIron.style.left = `${this.x}px`;
                this.currentIron.style.top = `${this.y}px`;
                document.body.appendChild(this.currentIron);
                this.hasIron = true;
                const campfire = this.findCampfire();
                if (campfire) {
                  const campfireRect = campfire.getBoundingClientRect();
                  while (!this.moveTowards(campfireRect.left, campfireRect.top)) {
                    this.currentIron.style.left = `${this.x}px`;
                    this.currentIron.style.top = `${this.y}px`;
                    await new Promise(resolve => setTimeout(resolve, 50));
                  }
                  if (this.currentIron) {
                    this.currentIron.remove();
                    this.currentIron = null;
                    this.hasIron = false;
                    totalIron++;
                    updateStats();
                  }
                }
              } else {
                this.currentSulfur = document.createElement('div');
                this.currentSulfur.className = 'sulfur-item';
                this.currentSulfur.style.left = `${this.x}px`;
                this.currentSulfur.style.top = `${this.y}px`;
                document.body.appendChild(this.currentSulfur);
                this.hasSulfur = true;
                const campfire = this.findCampfire();
                if (campfire) {
                  const campfireRect = campfire.getBoundingClientRect();
                  while (!this.moveTowards(campfireRect.left, campfireRect.top)) {
                    this.currentSulfur.style.left = `${this.x}px`;
                    this.currentSulfur.style.top = `${this.y}px`;
                    await new Promise(resolve => setTimeout(resolve, 50));
                  }
                  if (this.currentSulfur) {
                    this.currentSulfur.remove();
                    this.currentSulfur = null;
                    this.hasSulfur = false;
                    totalSulfur++;
                    updateStats();
                  }
                }
              }
              this.digging = false;
              this.currentMine = null;
              mine.remove();
            }
          }
        }
        if (!this.digging) {
          this.task = 'wander';
        }
      } else if (this.task === 'huntCow') {
        const cows = document.querySelectorAll('.cow');
        if (cows.length > 0) {
          const nearestCow = Array.from(cows).reduce((nearest, cow) => {
            const rect = cow.getBoundingClientRect();
            const dx = rect.left - this.x;
            const dy = rect.top - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (!nearest || dist < nearest.dist) {
              return {
                cow,
                dist
              };
            }
            return nearest;
          }, null);
          if (nearestCow) {
            const rect = nearestCow.cow.getBoundingClientRect();
            while (!this.moveTowards(rect.left, rect.top)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            nearestCow.cow.remove();
            totalCows--;
            const meat = document.createElement('div');
            meat.className = 'raw-beef';
            meat.style.left = `${rect.left}px`;
            meat.style.top = `${rect.top}px`;
            document.body.appendChild(meat);
            totalMeat++;
            updateStats();
          }
        }
        this.task = 'wander';
      } else if (this.task === 'buildFlat') {
        if (totalStone >= STONE_NEEDED_FOR_FLAT) {
          const buildLocation = this.findBuildingLocation();
          if (buildLocation) {
            while (!this.moveTowards(buildLocation.x, buildLocation.y)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 3000));
            if (totalStone >= STONE_NEEDED_FOR_FLAT) {
              const flat = document.createElement('div');
              flat.className = 'flat';
              const tile = this.grid.children[Math.floor(buildLocation.y / 64) * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + Math.floor(buildLocation.x / 64)];
              if (tile) {
                tile.style.position = 'relative';
                tile.appendChild(flat);
                totalStone -= STONE_NEEDED_FOR_FLAT;
                updateStats();
                const currentHumans = Array.from(document.querySelectorAll('.human')).length;
                for (let i = 0; i < 3; i++) {
                  new Human(this.grid, buildLocation.x, buildLocation.y);
                }
              }
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'buildCrossTotem') {
        if (totalLogs >= WOOD_FOR_TOTEM && !hasBuiltTotem && document.querySelectorAll('.cross-totem, .islam-totem').length === 0) {
          const buildLocation = this.findBuildingLocation();
          if (buildLocation) {
            while (!this.moveTowards(buildLocation.x, buildLocation.y)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 3000));
            if (totalLogs >= WOOD_FOR_TOTEM && !hasBuiltTotem && document.querySelectorAll('.cross-totem, .islam-totem').length === 0) {
              const totem = document.createElement('div');
              totem.className = 'cross-totem';
              const tile = this.grid.children[Math.floor(buildLocation.y / 64) * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + Math.floor(buildLocation.x / 64)];
              if (tile) {
                tile.appendChild(totem);
                totalLogs -= WOOD_FOR_TOTEM;
                hasBuiltTotem = true;
                updateStats();
              }
            }
          }
        }
        this.task = 'wander';
      } else if (this.task === 'buildIslamTotem') {
        if (totalLogs >= WOOD_FOR_TOTEM && !hasBuiltTotem && document.querySelectorAll('.cross-totem, .islam-totem').length === 0) {
          const buildLocation = this.findBuildingLocation();
          if (buildLocation) {
            while (!this.moveTowards(buildLocation.x, buildLocation.y)) {
              await new Promise(resolve => setTimeout(resolve, 50));
            }
            await new Promise(resolve => setTimeout(resolve, 3000));
            if (totalLogs >= WOOD_FOR_TOTEM && !hasBuiltTotem && document.querySelectorAll('.cross-totem, .islam-totem').length === 0) {
              const totem = document.createElement('div');
              totem.className = 'islam-totem';
              const tile = this.grid.children[Math.floor(buildLocation.y / 64) * getComputedStyle(this.grid).gridTemplateColumns.split(' ').length + Math.floor(buildLocation.x / 64)];
              if (tile) {
                tile.appendChild(totem);
                totalLogs -= WOOD_FOR_TOTEM;
                hasBuiltTotem = true;
                updateStats();
              }
            }
          }
        }
        this.task = 'wander';
      }
    }
  }
}
function createTileGrid() {
  const tileGrid = document.querySelector('.tile-grid');
  const tileSize = 64;
  const cols = Math.ceil(window.innerWidth / tileSize) + 1;
  const rows = Math.ceil(window.innerHeight / tileSize) + 1;
  tileGrid.style.left = '0';
  tileGrid.style.top = '0';
  tileGrid.style.gridTemplateColumns = `repeat(${cols}, ${tileSize}px)`;
  tileGrid.style.gridTemplateRows = `repeat(${rows}, ${tileSize}px)`;
  const totalTiles = cols * rows;
  const noiseScale = 50;
  const noise = generatePerlinNoise(cols, rows, noiseScale);
  const riverPaths = [];
  const numRivers = Math.floor(Math.random() * 2) + 2;
  let path = [];
  let currentCol = Math.floor(Math.random() * cols);
  let currentRow = 0;
  while (currentRow < rows) {
    path.push(currentRow * cols + currentCol);
    currentRow++;
    if (Math.random() < 0.4) {
      const shift = Math.random() < 0.5 ? 1 : -1;
      currentCol += shift;
      if (Math.random() < 0.3) {
        path.push(currentRow * cols + (currentCol - shift));
      }
      currentCol = Math.max(0, Math.min(cols - 1, currentCol));
    }
  }
  riverPaths.push(path);
  for (let r = 1; r < numRivers; r++) {
    path = [];
    const targetRiver = riverPaths[0];
    const connectionPoint = targetRiver[Math.floor(Math.random() * targetRiver.length)];
    const targetRow = Math.floor(connectionPoint / cols);
    const targetCol = connectionPoint % cols;
    currentCol = Math.random() < 0.5 ? 0 : cols - 1;
    currentRow = Math.floor(Math.random() * rows);
    while (currentCol !== targetCol || currentRow !== targetRow) {
      path.push(currentRow * cols + currentCol);
      if (currentCol < targetCol) currentCol++;
      if (currentCol > targetCol) currentCol--;
      if (currentRow < targetRow) currentRow++;
      if (currentRow > targetRow) currentRow--;
      if (Math.random() < 0.2) {
        if (Math.random() < 0.5) {
          path.push(currentRow * cols + (currentCol + 1));
        } else {
          path.push(currentRow * cols + (currentCol - 1));
        }
      }
    }
    riverPaths.push(path);
  }
  const allRiverTiles = new Set();
  for (const path of riverPaths) {
    for (let i = 0; i < path.length - 1; i++) {
      const current = path[i];
      const next = path[i + 1];
      const currentCol = current % cols;
      const currentRow = Math.floor(current / cols);
      const nextCol = next % cols;
      const nextRow = Math.floor(next / cols);
      if (currentCol !== nextCol && currentRow !== nextRow) {
        allRiverTiles.add(currentRow * cols + nextCol);
        allRiverTiles.add(nextRow * cols + currentCol);
      }
      allRiverTiles.add(current);
      allRiverTiles.add(next);
    }
    allRiverTiles.add(path[path.length - 1]);
  }
  let campfireLocation;
  const centerCol = Math.floor(cols / 2);
  const centerRow = Math.floor(rows / 2);
  const radius = Math.min(centerCol, centerRow) - 1;
  do {
    const angle = Math.random() * Math.PI * 2;
    const distance = Math.random() * radius;
    const offsetCol = Math.floor(Math.cos(angle) * distance);
    const offsetRow = Math.floor(Math.sin(angle) * distance);
    campfireLocation = (centerRow + offsetRow) * cols + (centerCol + offsetCol);
  } while (allRiverTiles.has(campfireLocation));
  for (let i = 0; i < totalTiles; i++) {
    const tile = document.createElement('div');
    const noiseVal = noise[Math.floor(i / cols) * cols + i % cols];
    if (allRiverTiles.has(i)) {
      tile.className = 'water-tile';
    } else if (noiseVal > 0.7) {
      tile.className = 'snow-tile';
      if (Math.random() < 0.2) {
        if (Math.random() < 0.3) {
          const tree = document.createElement('div');
          tree.className = 'snowy-tree';
          tree.style.animationDelay = `${Math.random() * 2}s`;
          tile.appendChild(tree);
        } else if (Math.random() < 0.3) {
          const rock = document.createElement('div');
          rock.className = 'rock';
          tile.appendChild(rock);
          setTimeout(() => {
            if (tile && !tile.querySelector('.tree, .snowy-tree, .rock, .house, .campfire, .farm-tile, .farm-tile-cabbage, .windmill, .fishing-dock, .iron-deposit, .sulfur-deposit')) {
              const newRock = document.createElement('div');
              newRock.className = 'rock';
              tile.appendChild(newRock);
            }
          }, ROCK_REGROW_TIME);
        } else if (Math.random() < 0.2) {
          const ironDeposit = document.createElement('div');
          ironDeposit.className = 'iron-deposit';
          tile.appendChild(ironDeposit);
          setTimeout(() => {
            if (tile && !tile.querySelector('.tree, .snowy-tree, .rock, .house, .campfire, .farm-tile, .farm-tile-cabbage, .windmill, .fishing-dock, .iron-deposit, .sulfur-deposit')) {
              const newIronDeposit = document.createElement('div');
              newIronDeposit.className = 'iron-deposit';
              tile.appendChild(newIronDeposit);
            }
          }, ROCK_REGROW_TIME);
        } else if (Math.random() < 0.2) {
          const sulfurDeposit = document.createElement('div');
          sulfurDeposit.className = 'sulfur-deposit';
          tile.appendChild(sulfurDeposit);
          setTimeout(() => {
            if (tile && !tile.querySelector('.tree, .snowy-tree, .rock, .house, .campfire, .farm-tile, .farm-tile-cabbage, .windmill, .fishing-dock, .iron-deposit, .sulfur-deposit')) {
              const newSulfurDeposit = document.createElement('div');
              newSulfurDeposit.className = 'sulfur-deposit';
              tile.appendChild(newSulfurDeposit);
            }
          }, ROCK_REGROW_TIME);
        }
      }
    } else if (noiseVal < 0.3) {
      tile.className = 'sand-tile';
      if (Math.random() < 0.15) {
        const cactus = document.createElement('div');
        cactus.className = 'cactus';
        tile.appendChild(cactus);
      }
    } else {
      tile.className = 'tile';
      if (i === campfireLocation) {
        const campfire = document.createElement('div');
        campfire.className = 'campfire';
        tile.appendChild(campfire);
        campfire.setAttribute('data-biome', tile.className);
      } else if (Math.random() < 0.2 && !allRiverTiles.has(i)) {
        if (Math.random() < 0.4) {
          const tree = document.createElement('div');
          tree.className = 'tree';
          tree.style.animationDelay = `${Math.random() * 2}s`;
          tile.appendChild(tree);
        } else if (Math.random() < 0.3) {
          const rock = document.createElement('div');
          rock.className = 'rock';
          tile.appendChild(rock);
          setTimeout(() => {
            if (tile && !tile.querySelector('.tree, .rock, .house, .campfire, .farm-tile, .farm-tile-cabbage, .windmill, .fishing-dock, .iron-deposit, .sulfur-deposit')) {
              const newRock = document.createElement('div');
              newRock.className = 'rock';
              tile.appendChild(newRock);
            }
          }, ROCK_REGROW_TIME);
        } else if (Math.random() < 0.15) {
          const ironDeposit = document.createElement('div');
          ironDeposit.className = 'iron-deposit';
          tile.appendChild(ironDeposit);
          setTimeout(() => {
            if (tile && !tile.querySelector('.tree, .rock, .house, .campfire, .farm-tile, .farm-tile-cabbage, .windmill, .fishing-dock, .iron-deposit, .sulfur-deposit')) {
              const newIronDeposit = document.createElement('div');
              newIronDeposit.className = 'iron-deposit';
              tile.appendChild(newIronDeposit);
            }
          }, ROCK_REGROW_TIME);
        } else if (Math.random() < 0.15) {
          const sulfurDeposit = document.createElement('div');
          sulfurDeposit.className = 'sulfur-deposit';
          tile.appendChild(sulfurDeposit);
          setTimeout(() => {
            if (tile && !tile.querySelector('.tree, .rock, .house, .campfire, .farm-tile, .farm-tile-cabbage, .windmill, .fishing-dock, .iron-deposit, .sulfur-deposit')) {
              const newSulfurDeposit = document.createElement('div');
              newSulfurDeposit.className = 'sulfur-deposit';
              tile.appendChild(newSulfurDeposit);
            }
          }, ROCK_REGROW_TIME);
        }
      } else if (!allRiverTiles.has(i) && Math.random() < SPAWN_COW_CHANCE && totalCows < 5) {
        const rect = tile.getBoundingClientRect();
        new Cow(tileGrid, rect.left, rect.top);
        totalCows++;
      }
    }
    tileGrid.appendChild(tile);
  }
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const i = row * cols + col;
      const tile = tileGrid.children[i];
      if (tile.classList.contains('water-tile')) {
        const up = row > 0 ? tileGrid.children[(row - 1) * cols + col] : null;
        const down = row < rows - 1 ? tileGrid.children[(row + 1) * cols + col] : null;
        const left = col > 0 ? tileGrid.children[row * cols + (col - 1)] : null;
        const right = col < cols - 1 ? tileGrid.children[row * cols + (col + 1)] : null;
        const adjacentTiles = [up, down, left, right].filter(t => t);
        const touchesSnow = adjacentTiles.some(t => t.classList.contains('snow-tile'));
        const touchesIce = adjacentTiles.some(t => t.classList.contains('ice-tile'));
        const touchesGrassOrSand = adjacentTiles.some(t => t.classList.contains('tile') || t.classList.contains('sand-tile'));
        if (touchesSnow || touchesIce && !touchesGrassOrSand) {
          tile.className = 'ice-tile';
        }
      }
    }
  }
  for (let i = 0; i < 5; i++) {
    const human = new Human(tileGrid, Math.random() * window.innerWidth, Math.random() * window.innerHeight);
    if (!hasBuiltTotem && totalLogs >= WOOD_FOR_TOTEM && document.querySelectorAll('.cross-totem, .islam-totem').length === 0) {
      const campfire = document.querySelector('.campfire');
      const campfireRect = campfire.getBoundingClientRect();
      const tileSize = 64;
      const col = Math.floor(campfireRect.left / tileSize);
      const row = Math.floor(campfireRect.top / tileSize);
      const tileGrid = document.querySelector('.tile-grid');
      const gridCols = getComputedStyle(tileGrid).gridTemplateColumns.split(' ').length;
      const campfireTile = tileGrid.children[row * gridCols + col];
      if (campfireTile.classList.contains('sand-tile')) {
        human.task = Math.random() < 0.75 ? 'buildIslamTotem' : 'buildCrossTotem';
      } else if (campfireTile.classList.contains('snow-tile') || campfireTile.classList.contains('tile')) {
        human.task = Math.random() < 0.75 ? 'buildCrossTotem' : 'buildIslamTotem';
      }
    } else if (houses.size < 5) {
      if (totalLogs >= LOGS_NEEDED_FOR_HOUSE) {
        human.task = 'buildHouse';
      } else {
        human.task = 'cutTree';
      }
    } else {
      const woodHouses = Array.from(houses).filter(h => !h.classList.contains('stone-house'));
      const stoneHouses = Array.from(houses).filter(h => h.classList.contains('stone-house'));
      const availableHouseSpace = woodHouses.length * HUMANS_PER_HOUSE + stoneHouses.length * HUMANS_PER_STONE_HOUSE - humanCount;
    }
  }
  for (let i = 0; i < Math.min(totalMuskets, humanCount); i++) {
    const humans = document.querySelectorAll('.human');
    const randomHuman = humans[Math.floor(Math.random() * humans.length)];
    if (randomHuman) {
      const instance = Array.from(document.querySelectorAll('.human')).find(h => h === randomHuman);
      if (instance) {
        instance.isHunter = true;
        instance.hasMusket = true;
        instance.element.className = 'hunter';
      }
    }
  }
  if (!hasBuiltTotem && totalLogs >= WOOD_FOR_TOTEM) {}
}
class Cow {
  constructor(grid, startX, startY) {
    this.element = document.createElement('div');
    this.element.className = 'cow';
    document.body.appendChild(this.element);
    this.x = startX;
    this.y = startY;
    this.grid = grid;
    this.targetX = startX;
    this.targetY = startY;
    this.speed = 2;
    this.updatePosition();
    this.think();
  }
  updatePosition() {
    this.element.style.left = `${this.x}px`;
    this.element.style.top = `${this.y}px`;
  }
  moveTowards(targetX, targetY) {
    const dx = targetX - this.x;
    const dy = targetY - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const tileSize = 64;
    const targetCol = Math.floor(targetX / tileSize);
    const targetRow = Math.floor(targetY / tileSize);
    const tileGrid = document.querySelector('.tile-grid');
    const gridCols = getComputedStyle(tileGrid).gridTemplateColumns.split(' ').length;
    const targetTile = tileGrid.children[targetRow * gridCols + targetCol];
    if (targetTile && (targetTile.classList.contains('water-tile') || targetTile.classList.contains('ice-tile'))) {
      this.targetX = this.x;
      this.targetY = this.y;
      return true;
    }
    if (distance > this.speed) {
      this.x += dx / distance * this.speed;
      this.y += dy / distance * this.speed;
      this.updatePosition();
      return false;
    }
    return true;
  }
  async think() {
    while (true) {
      this.targetX = Math.random() * this.grid.offsetWidth;
      this.targetY = Math.random() * this.grid.offsetHeight;
      while (!this.moveTowards(this.targetX, this.targetY)) {
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
}
createTileGrid();
updateStats();</script>
</body></html>