body {
    margin: 0;
    padding: 20px;
    background: #8B4513;
    font-family: Arial, sans-serif;
    color: #FFD700;
    background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23703600' d='M0 0h100v100H0z'/%3E%3Cpath fill='%23612e00' d='M10 10h10v10H10zM30 30h10v10H30zM50 50h10v10H50zM70 70h10v10H70z'/%3E%3C/svg%3E");
}

.setup-panel {
    width: 800px;
    margin: 20px auto;
    padding: 20px;
    background: rgba(139, 69, 19, 0.9);
    border: 2px solid #FFD700;
    border-radius: 10px;
}

.cpu-config {
    margin: 10px 0;
    padding: 10px;
    background: rgba(0,0,0,0.2);
    border-radius: 5px;
}

input, button {
    margin: 5px;
    padding: 5px;
    border: 2px solid #FFD700;
    background: #8B4513;
    color: #FFD700;
    border-radius: 5px;
}

input[type="color"] {
    width: 50px;
    height: 30px;
    padding: 0;
    cursor: pointer;
}

button {
    cursor: pointer;
    font-weight: bold;
    padding: 10px 20px;
}

button:hover {
    background: #A0522D;
}

.arena {
    width: 800px;
    height: 500px;
    border: 5px solid #8B4513;
    background: #DEB887;
    position: relative;
    margin: auto;
    overflow: hidden;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    display: none;
    transition: all 0.5s;
}

.arena.large {
    width: 1200px;
    height: 800px;
}

.obstacle {
    position: absolute;
    pointer-events: none;
}

.cpu {
    width: 50px;
    height: 50px;
    position: absolute;
    cursor: pointer;
    transition: transform 0.2s;
    z-index: 2;
}

.cpu svg {
    width: 100%;
    height: 100%;
}

.bullet {
    width: 10px;
    height: 4px;
    background: #FFD700;
    position: absolute;
    border-radius: 2px;
    z-index: 3;
}

.health {
    position: absolute;
    top: -20px;
    width: 100%;
    text-align: center;
    font-size: 14px;
    color: #FF0000;
}

.score-board {
    text-align: center;
    margin: 20px;
    font-size: 24px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}

.cpu-name {
    position: absolute;
    bottom: -20px;
    width: 100%;
    text-align: center;
    font-size: 12px;
    color: #FFD700;
    text-shadow: 1px 1px 2px black;
}

@keyframes shoot {
    from { transform: scale(1); }
    to { transform: scale(1.2); }
}

@keyframes hit {
    from { filter: brightness(100%); }
    to { filter: brightness(200%); }
}

.eliminated {
    opacity: 0.5;
    pointer-events: none;
}

.kill-feed {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 300px;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #FFD700;
    border-radius: 5px;
    padding: 10px;
    color: #FFD700;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
}

.kill-feed-entry {
    margin: 5px 0;
    padding: 5px;
    border-bottom: 1px solid rgba(255, 215, 0, 0.3);
}

.kill-feed-entry:last-child {
    border-bottom: none;
}

.leaderboard {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    border: 3px solid #FFD700;
    border-radius: 10px;
    padding: 20px;
    color: #FFD700;
    z-index: 100;
    min-width: 300px;
}

.leaderboard h2 {
    text-align: center;
    margin-bottom: 20px;
}

.leaderboard-entry {
    display: flex;
    align-items: center;
    margin: 10px 0;
    padding: 5px;
    border-bottom: 1px solid rgba(255, 215, 0, 0.3);
}

.placement {
    font-size: 24px;
    font-weight: bold;
    margin-right: 15px;
    width: 30px;
}

.player-info {
    flex-grow: 1;
}

.player-color {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    margin-right: 10px;
    display: inline-block;
}

.timer {
    position: fixed;
    top: 20px;
    left: 20px;
    font-size: 24px;
    color: #FFD700;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 5px;
    border: 2px solid #FFD700;
}

.lava {
    position: absolute;
    background: linear-gradient(45deg, #ff4500, #ff8c00);
    opacity: 0.8;
    z-index: 1;
}

@keyframes firework {
    0% { transform: scale(0); opacity: 1; }
    50% { transform: scale(1); opacity: 0.8; }
    100% { transform: scale(1.5); opacity: 0; }
}

.firework {
    position: absolute;
    pointer-events: none;
    z-index: 1000;
}

.firework-particle {
    position: absolute;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    animation: firework-particle 1s forwards;
}

@keyframes firework-particle {
    0% { transform: translate(0, 0); opacity: 1; }
    100% { transform: translate(var(--tx), var(--ty)); opacity: 0; }
}
</style></head><body>
<div class="setup-panel" id="setup">
    <h2>Wild West CPU Showdown Setup</h2>
    <div>
        <label>Number of CPUs (2-20): </label>
        <input type="number" id="cpuCount" min="2" max="20" value="4">
        <button onclick="generateCPUInputs()">Update CPU Count</button>
    </div>
    <div id="cpuConfigs"></div>
    <button onclick="startGame()">Start Showdown!</button>
</div>
<audio id="bgMusic" loop muted>
  <source src="https://ia601609.us.archive.org/20/items/western-swing_201910/WesternSwing.mp3" type="audio/mpeg">
</audio>
<div class="score-board">Wild West CPU Showdown!</div>
<div class="arena" id="arena"></div>

<script>class CPU {
  constructor(id, x, y, color, name, arenaWidth, arenaHeight) {
    this.id = id;
    this.x = x;
    this.y = y;
    this.color = color;
    this.name = name;
    this.health = 3;
    this.element = this.createCPUElement();
    this.direction = Math.random() * Math.PI * 2;
    this.speed = 2;
    this.lastShot = 0;
    this.active = true;
    this.arenaWidth = arenaWidth;
    this.arenaHeight = arenaHeight;
  }
  createCPUElement() {
    const cpu = document.createElement('div');
    cpu.className = 'cpu';
    cpu.innerHTML = `
            <div class="health">❤️❤️❤️</div>
            <svg viewBox="0 0 50 50">
                <rect x="10" y="10" width="30" height="30" fill="${this.color}"/>
                <rect x="35" y="20" width="15" height="5" fill="#333"/>
            </svg>
            <div class="cpu-name">${this.name}</div>
        `;
    cpu.style.left = this.x + 'px';
    cpu.style.top = this.y + 'px';
    return cpu;
  }
  update() {
    if (!this.active) return;
    const nextX = this.x + Math.cos(this.direction) * this.speed;
    const nextY = this.y + Math.sin(this.direction) * this.speed;
    if (this.checkObstacleCollision(nextX, nextY)) {
      this.direction += Math.PI / 2 + Math.random() * Math.PI;
      return;
    }
    this.x = nextX;
    this.y = nextY;
    if (this.x < 0 || this.x > this.arenaWidth - 50) this.direction = Math.PI - this.direction;
    if (this.y < 0 || this.y > this.arenaHeight - 50) this.direction = -this.direction;
    this.element.style.left = this.x + 'px';
    this.element.style.top = this.y + 'px';
    this.element.style.transform = `rotate(${this.direction * 180 / Math.PI}deg)`;
    if (Date.now() - this.lastShot > 1000 && Math.random() < 0.02) {
      this.shoot();
    }
  }
  checkObstacleCollision(nextX, nextY) {
    const cpuLeft = nextX;
    const cpuRight = nextX + 50;
    const cpuTop = nextY;
    const cpuBottom = nextY + 50;
    const saloonX = this.arenaWidth * 0.4;
    const saloonY = this.arenaHeight * 0.3;
    const saloonWidth = this.arenaWidth * 0.2;
    const saloonHeight = this.arenaHeight * 0.4;
    if (cpuRight > saloonX && cpuLeft < saloonX + saloonWidth && cpuBottom > saloonY && cpuTop < saloonY + saloonHeight) {
      return true;
    }
    const obstacles = document.querySelectorAll('.obstacle');
    for (let obstacle of obstacles) {
      const rect = obstacle.getBoundingClientRect();
      const arenaRect = arena.getBoundingClientRect();
      const obstacleLeft = rect.left - arenaRect.left;
      const obstacleRight = obstacleLeft + rect.width;
      const obstacleTop = rect.top - arenaRect.top;
      const obstacleBottom = obstacleTop + rect.height;
      if (cpuRight > obstacleLeft && cpuLeft < obstacleRight && cpuBottom > obstacleTop && cpuTop < obstacleBottom) {
        return true;
      }
    }
    return false;
  }
  shoot() {
    if (!this.active) return;
    this.lastShot = Date.now();
    const bullet = document.createElement('div');
    bullet.className = 'bullet';
    bullet.style.left = this.x + 25 + 'px';
    bullet.style.top = this.y + 25 + 'px';
    const angle = this.direction;
    const speed = 5;
    const dx = Math.cos(angle) * speed;
    const dy = Math.sin(angle) * speed;
    arena.appendChild(bullet);
    this.element.style.animation = 'shoot 0.1s';
    const checkBulletCollision = (x, y) => {
      const saloonX = this.arenaWidth * 0.4;
      const saloonY = this.arenaHeight * 0.3;
      const saloonWidth = this.arenaWidth * 0.2;
      const saloonHeight = this.arenaHeight * 0.4;
      if (x > saloonX && x < saloonX + saloonWidth && y > saloonY && y < saloonY + saloonHeight) {
        return true;
      }
      const obstacles = document.querySelectorAll('.obstacle');
      for (let obstacle of obstacles) {
        const rect = obstacle.getBoundingClientRect();
        const arenaRect = arena.getBoundingClientRect();
        const obstacleLeft = rect.left - arenaRect.left;
        const obstacleRight = obstacleLeft + rect.width;
        const obstacleTop = rect.top - arenaRect.top;
        const obstacleBottom = obstacleTop + rect.height;
        if (x > obstacleLeft && x < obstacleRight && y > obstacleTop && y < obstacleBottom) {
          return true;
        }
      }
      return false;
    };
    const animateBullet = () => {
      const x = parseFloat(bullet.style.left);
      const y = parseFloat(bullet.style.top);
      if (checkBulletCollision(x, y)) {
        bullet.remove();
        return;
      }
      if (x < 0 || x > this.arenaWidth || y < 0 || y > this.arenaHeight) {
        bullet.remove();
        return;
      }
      for (let cpu of cpus) {
        if (cpu.id !== this.id && cpu.active) {
          const dx = x - (cpu.x + 25);
          const dy = y - (cpu.y + 25);
          if (Math.sqrt(dx * dx + dy * dy) < 25) {
            cpu.hit(this);
            bullet.remove();
            return;
          }
        }
      }
      bullet.style.left = x + dx + 'px';
      bullet.style.top = y + dy + 'px';
      bullet.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
      requestAnimationFrame(animateBullet);
    };
    requestAnimationFrame(animateBullet);
    setTimeout(() => this.element.style.animation = '', 100);
  }
  hit(shooter) {
    this.health--;
    this.element.style.animation = 'hit 0.2s';
    this.element.querySelector('.health').innerHTML = '❤️'.repeat(this.health);
    addKillFeedEntry(shooter, this);
    if (this.health <= 0) {
      this.eliminate();
    }
    setTimeout(() => this.element.style.animation = '', 200);
  }
  eliminate() {
    this.active = false;
    this.element.classList.add('eliminated');
    const cpuCenterX = this.x + 25;
    const cpuCenterY = this.y + 25;
    createFirework(cpuCenterX, cpuCenterY, this.color);
    checkGameOver();
  }
}
const arena = document.getElementById('arena');
let cpus = [];
let bgMusic;
let gameStartTime = 0;
let lavaElements = [];
const LAVA_SPEED = 1;
const LAVA_DAMAGE_INTERVAL = 1000;
let lastLavaDamageTime = 0;
function initAudio() {
  bgMusic = document.getElementById('bgMusic');
  bgMusic.volume = 0.3;
  bgMusic.play().catch(() => {
    console.log('Audio playback requires user interaction first');
  });
}
function generateObstacles(arenaWidth, arenaHeight, cpuPositions = []) {
  let obstacles = '';
  const saloonWidth = arenaWidth * 0.2;
  const saloonHeight = arenaHeight * 0.4;
  const saloonX = arenaWidth * 0.4;
  const saloonY = arenaHeight * 0.3;
  obstacles += `
        <svg class="obstacle" style="width: ${saloonWidth}px; height: ${saloonHeight}px; left: ${saloonX}px; top: ${saloonY}px; z-index: 1;">
            <rect x="10%" y="30%" width="80%" height="70%" fill="#8B4513"/>
            <rect x="0" y="20%" width="100%" height="15%" fill="#A0522D"/>
            <text x="30%" y="50%" fill="#FFD700" font-size="20">SALOON</text>
            <rect x="40%" y="60%" width="20%" height="40%" fill="#4A2810"/>
        </svg>
    `;
  const obstacleCount = Math.floor(arenaWidth * arenaHeight / 40000);
  for (let i = 0; i < obstacleCount; i++) {
    const obstacleWidth = Math.random() < 0.5 ? 80 : 40;
    const obstacleHeight = Math.random() < 0.5 ? 60 : 80;
    let x = Math.random() * (arenaWidth - obstacleWidth);
    let y = Math.random() * (arenaHeight - obstacleHeight);
    const overlapsWithSaloon = x > saloonX - 100 && x < saloonX + saloonWidth + 100 && y > saloonY - 100 && y < saloonY + saloonHeight + 100;
    const overlapsWithCPU = cpuPositions.some(pos => {
      return x < pos.x + 100 && x + obstacleWidth > pos.x - 100 && y < pos.y + 100 && y + obstacleHeight > pos.y - 100;
    });
    if (overlapsWithSaloon || overlapsWithCPU) {
      i--;
      continue;
    }
    if (Math.random() < 0.5) {
      obstacles += `
            <svg class="obstacle" style="width: 80px; height: 60px; left: ${x}px; top: ${y}px;">
                <path d="M10,50 Q25,20 40,50 Q60,30 70,50 Z" fill="#808080"/>
            </svg>
        `;
    } else {
      obstacles += `
            <svg class="obstacle" style="width: 40px; height: 80px; left: ${x}px; top: ${y}px;">
                <path d="M20,80 L20,30 L10,30 L10,20 L20,20 L20,10 L30,10 L30,20 L40,20 L40,30 L30,30 L30,80 Z" fill="#2F4F2F"/>
            </svg>
        `;
    }
  }
  return obstacles;
}
function generateCPUInputs() {
  const count = document.getElementById('cpuCount').value;
  const configsDiv = document.getElementById('cpuConfigs');
  configsDiv.innerHTML = '';
  for (let i = 0; i < count; i++) {
    const cpuConfig = document.createElement('div');
    cpuConfig.className = 'cpu-config';
    cpuConfig.innerHTML = `
            <label>CPU ${i + 1} Name: </label>
            <input type="text" id="name${i}" value="CPU ${i + 1}">
            <label>Color: </label>
            <input type="color" id="color${i}" value="${'#' + Math.floor(Math.random() * 16777215).toString(16)}">
        `;
    configsDiv.appendChild(cpuConfig);
  }
}
function startGame() {
  initAudio();
  try {
    bgMusic.play();
  } catch (e) {
    console.log('Audio playback requires user interaction first');
  }
  const count = parseInt(document.getElementById('cpuCount').value);
  document.getElementById('setup').style.display = 'none';
  arena.style.display = 'block';
  const isLargeArena = count >= 10;
  const arenaWidth = isLargeArena ? 1200 : 800;
  const arenaHeight = isLargeArena ? 800 : 500;
  arena.style.width = arenaWidth + 'px';
  arena.style.height = arenaHeight + 'px';
  arena.classList.toggle('large', isLargeArena);
  cpus = [];
  const cpuPositions = [];
  for (let i = 0; i < count; i++) {
    let x, y;
    let validPosition = false;
    do {
      x = 50 + Math.random() * (arenaWidth - 100);
      y = 50 + Math.random() * (arenaHeight - 100);
      const overlapsWithSaloon = x > arenaWidth * 0.3 && x < arenaWidth * 0.7 && y > arenaHeight * 0.2 && y < arenaHeight * 0.8;
      const overlapsWithCPU = cpuPositions.some(pos => {
        const dx = pos.x - x;
        const dy = pos.y - y;
        return Math.sqrt(dx * dx + dy * dy) < 100;
      });
      validPosition = !overlapsWithSaloon && !overlapsWithCPU;
    } while (!validPosition);
    cpuPositions.push({
      x,
      y
    });
  }
  arena.innerHTML = generateObstacles(arenaWidth, arenaHeight, cpuPositions);
  const killFeed = document.createElement('div');
  killFeed.className = 'kill-feed';
  document.body.appendChild(killFeed);
  gameStartTime = Date.now();
  const timer = document.createElement('div');
  timer.className = 'timer';
  document.body.appendChild(timer);
  const lavaTop = document.createElement('div');
  const lavaBottom = document.createElement('div');
  const lavaLeft = document.createElement('div');
  const lavaRight = document.createElement('div');
  [lavaTop, lavaBottom, lavaLeft, lavaRight].forEach(el => {
    el.className = 'lava';
    el.style.display = 'none';
    arena.appendChild(el);
    lavaElements.push(el);
  });
  for (let i = 0; i < count; i++) {
    const name = document.getElementById(`name${i}`).value;
    const color = document.getElementById(`color${i}`).value;
    const position = cpuPositions[i];
    const cpu = new CPU(i, position.x, position.y, color, name, arenaWidth, arenaHeight);
    arena.appendChild(cpu.element);
    cpus.push(cpu);
  }
  update();
}
function update() {
  const elapsed = Date.now() - gameStartTime;
  const timerElement = document.querySelector('.timer');
  timerElement.textContent = `Time: ${Math.floor(elapsed / 1000)}s`;
  if (elapsed >= 120000) {
    const lavaProgress = Math.min(1, (elapsed - 120000) / 30000);
    const [top, bottom, left, right] = lavaElements;
    const lavaSize = 50 * lavaProgress;
    lavaElements.forEach(el => el.style.display = 'block');
    top.style.top = '0';
    top.style.left = '0';
    top.style.width = '100%';
    top.style.height = lavaSize + 'px';
    bottom.style.bottom = '0';
    bottom.style.left = '0';
    bottom.style.width = '100%';
    bottom.style.height = lavaSize + 'px';
    left.style.left = '0';
    left.style.top = lavaSize + 'px';
    left.style.width = lavaSize + 'px';
    left.style.height = arena.offsetHeight - 2 * lavaSize + 'px';
    right.style.right = '0';
    right.style.top = lavaSize + 'px';
    right.style.width = lavaSize + 'px';
    right.style.height = arena.offsetHeight - 2 * lavaSize + 'px';
    if (Date.now() - lastLavaDamageTime > LAVA_DAMAGE_INTERVAL) {
      cpus.forEach(cpu => {
        if (!cpu.active) return;
        const cpuRect = {
          left: cpu.x,
          right: cpu.x + 50,
          top: cpu.y,
          bottom: cpu.y + 50
        };
        if (cpuRect.left < lavaSize || cpuRect.right > arena.offsetWidth - lavaSize || cpuRect.top < lavaSize || cpuRect.bottom > arena.offsetHeight - lavaSize) {
          cpu.health--;
          cpu.element.querySelector('.health').innerHTML = '❤️'.repeat(cpu.health);
          if (cpu.health <= 0) {
            cpu.eliminate();
          }
        }
      });
      lastLavaDamageTime = Date.now();
    }
  }
  cpus.forEach(cpu => cpu.update());
  requestAnimationFrame(update);
}
function checkGameOver() {
  const activeCPUs = cpus.filter(cpu => cpu.active);
  if (activeCPUs.length <= 1) {
    if (bgMusic && !bgMusic.paused) {
      bgMusic.pause();
    }
    bgMusic.currentTime = 0;
    const killFeed = document.querySelector('.kill-feed');
    if (killFeed) killFeed.remove();
    setTimeout(() => {
      showLeaderboard();
      const winner = activeCPUs[0];
      const replayBtn = document.createElement('button');
      replayBtn.innerText = 'Play Again';
      replayBtn.style.position = 'fixed';
      replayBtn.style.bottom = '20px';
      replayBtn.style.left = '50%';
      replayBtn.style.transform = 'translateX(-50%)';
      replayBtn.onclick = () => location.reload();
      document.body.appendChild(replayBtn);
    }, 1000);
  }
}
function addKillFeedEntry(killer, victim) {
  const killFeed = document.querySelector('.kill-feed');
  const entry = document.createElement('div');
  entry.className = 'kill-feed-entry';
  entry.innerHTML = `<span style="color: ${killer.color}">${killer.name}</span> shot <span style="color: ${victim.color}">${victim.name}</span>!`;
  killFeed.insertBefore(entry, killFeed.firstChild);
  while (killFeed.children.length > 10) {
    killFeed.removeChild(killFeed.lastChild);
  }
}
function showLeaderboard() {
  const leaderboard = document.createElement('div');
  leaderboard.className = 'leaderboard';
  let html = '<h2>Final Results</h2>';
  const sortedCPUs = [...cpus].sort((a, b) => {
    if (a.active && !b.active) return -1;
    if (!a.active && b.active) return 1;
    return b.health - a.health;
  });
  sortedCPUs.forEach((cpu, index) => {
    const placement = index + 1;
    const placementText = placement === 1 ? '🏆' : `${placement}${getOrdinalSuffix(placement)}`;
    html += `
            <div class="leaderboard-entry">
                <div class="placement">${placementText}</div>
                <div class="player-info">
                    <span class="player-color" style="background-color: ${cpu.color}"></span>
                    ${cpu.name} ${cpu.active ? '(Winner!)' : `(${cpu.health} ❤️ remaining)`}
                </div>
            </div>
        `;
  });
  leaderboard.innerHTML = html;
  document.body.appendChild(leaderboard);
}
function getOrdinalSuffix(num) {
  const j = num % 10,
    k = num % 100;
  if (j == 1 && k != 11) return "st";
  if (j == 2 && k != 12) return "nd";
  if (j == 3 && k != 13) return "rd";
  return "th";
}
function createFirework(x, y, color) {
  const firework = document.createElement('div');
  firework.className = 'firework';
  firework.style.left = x + 'px';
  firework.style.top = y + 'px';
  const burst = document.createElement('div');
  burst.style.width = '50px';
  burst.style.height = '50px';
  burst.style.background = `radial-gradient(circle, ${color}, transparent)`;
  burst.style.position = 'absolute';
  burst.style.left = '-25px';
  burst.style.top = '-25px';
  burst.style.animation = 'firework 0.8s forwards';
  firework.appendChild(burst);
  const particleCount = 20;
  for (let i = 0; i < particleCount; i++) {
    const particle = document.createElement('div');
    particle.className = 'firework-particle';
    particle.style.background = color;
    const angle = i * (360 / particleCount) + Math.random() * 20;
    const distance = 50 + Math.random() * 30;
    const tx = Math.cos(angle * Math.PI / 180) * distance;
    const ty = Math.sin(angle * Math.PI / 180) * distance;
    particle.style.setProperty('--tx', `${tx}px`);
    particle.style.setProperty('--ty', `${ty}px`);
    firework.appendChild(particle);
  }
  arena.appendChild(firework);
  setTimeout(() => firework.remove(), 1000);
}
generateCPUInputs();</script></body></html>