<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
body { 
  margin: 0;
  overflow: hidden;
  font-family: sans-serif;
}

#score {
  position: fixed;
  top: 20px;
  right: 20px;
  font-size: 24px;
  font-weight: bold;
  color: white;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  z-index: 100;
}

#instructions {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  color: white;
  text-align: center;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  z-index: 100;
}
</style>
</head>
<body>

<div id="score">Score: 0</div>
<div id="instructions">
  Use arrow keys or WASD to move<br>
  Left/Right arrow keys to rotate camera<br>
  Or hold right mouse button and move to rotate camera<br>
  Collect the floating bamboo!
</div>

<script>
// Scene setup
let scene, camera, renderer, panda, bamboo;
let score = 0;
const scoreElement = document.getElementById('score');
let cameraRotation = 0;
let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };
const CAMERA_ROTATION_SPEED = 0.05;

scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);

camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Modified Lighting setup
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(10, 20, 10);
directionalLight.castShadow = true;
directionalLight.shadow.camera.near = 0.1;
directionalLight.shadow.camera.far = 100;
directionalLight.shadow.camera.left = -50;
directionalLight.shadow.camera.right = 50;
directionalLight.shadow.camera.top = 50;
directionalLight.shadow.camera.bottom = -50;
directionalLight.shadow.mapSize.width = 2048;
directionalLight.shadow.mapSize.height = 2048;
scene.add(directionalLight);

// Add directionalLight target to scene
scene.add(directionalLight.target);

// Ground with better texture
const groundGeometry = new THREE.PlaneGeometry(100, 100, 100, 100);
const groundMaterial = new THREE.MeshStandardMaterial({ 
  color: 0x90EE90,
  roughness: 0.8,
  metalness: 0.2
});
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -2;
ground.receiveShadow = true;
scene.add(ground);

// Enhanced Panda with ears
function createPanda() {
  const pandaGroup = new THREE.Group();
  
  // Body
  const bodyGeometry = new THREE.SphereGeometry(1, 32, 32);
  const bodyMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xFFFFFF,
    roughness: 0.3,
    metalness: 0.1
  });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.castShadow = true;
  pandaGroup.add(body);
  
  // Eyes
  const eyeGeometry = new THREE.SphereGeometry(0.2, 32, 32);
  const eyeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x000000,
    roughness: 0.2,
    metalness: 0.8
  });
  
  const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
  leftEye.position.set(-0.3, 0.3, 0.8);
  leftEye.castShadow = true;
  pandaGroup.add(leftEye);
  
  const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
  rightEye.position.set(0.3, 0.3, 0.8);
  rightEye.castShadow = true;
  pandaGroup.add(rightEye);
  
  // Add ears
  const earGeometry = new THREE.CircleGeometry(0.4, 32);
  const earMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x000000,
    roughness: 0.3,
    metalness: 0.1,
    side: THREE.DoubleSide
  });
  
  // Left ear
  const leftEar = new THREE.Mesh(earGeometry, earMaterial);
  leftEar.position.set(-0.7, 0.8, 0);
  leftEar.rotation.y = Math.PI / 4;
  leftEar.rotation.x = -Math.PI / 6;
  leftEar.castShadow = true;
  pandaGroup.add(leftEar);
  
  // Right ear
  const rightEar = new THREE.Mesh(earGeometry, earMaterial);
  rightEar.position.set(0.7, 0.8, 0);
  rightEar.rotation.y = -Math.PI / 4;
  rightEar.rotation.x = -Math.PI / 6;
  rightEar.castShadow = true;
  pandaGroup.add(rightEar);
  
  return pandaGroup;
}

// Enhanced Bamboo
function createBamboo() {
  const bambooGroup = new THREE.Group();
  
  const stalkGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 16);
  const bambooMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x228B22,
    roughness: 0.6,
    metalness: 0.1
  });
  const stalk = new THREE.Mesh(stalkGeometry, bambooMaterial);
  stalk.castShadow = true;
  bambooGroup.add(stalk);
  
  return bambooGroup;
}

panda = createPanda();
scene.add(panda);
bamboo = createBamboo();
scene.add(bamboo);

// Camera setup
camera.position.set(0, 5, 10);
camera.lookAt(panda.position);

// Movement and camera rotation controls
const pandaVelocity = {
  x: 0,
  z: 0
};
const speed = 0.15;

// Mouse controls for camera rotation
document.addEventListener('mousedown', (e) => {
  if (e.button === 2) {
    isDragging = true;
    previousMousePosition = {
      x: e.clientX,
      y: e.clientY
    };
  }
});

document.addEventListener('mouseup', () => {
  isDragging = false;
});

document.addEventListener('mousemove', (e) => {
  if (isDragging) {
    const deltaMove = {
      x: e.clientX - previousMousePosition.x,
      y: e.clientY - previousMousePosition.y
    };

    cameraRotation += deltaMove.x * 0.01;

    previousMousePosition = {
      x: e.clientX,
      y: e.clientY
    };
  }
});

// Prevent context menu on right click
document.addEventListener('contextmenu', (e) => e.preventDefault());

// Movement controls
document.addEventListener('keydown', (e) => {
  switch(e.key) {
    case 'ArrowLeft':
      if (e.shiftKey) {
        pandaVelocity.x = -speed;
      } else {
        cameraRotation -= CAMERA_ROTATION_SPEED;
      }
      break;
    case 'ArrowRight':
      if (e.shiftKey) {
        pandaVelocity.x = speed;
      } else {
        cameraRotation += CAMERA_ROTATION_SPEED;
      }
      break;
    case 'a':
      pandaVelocity.x = -speed;
      break;
    case 'd':
      pandaVelocity.x = speed;
      break;
    case 'ArrowUp':
    case 'w':
      pandaVelocity.z = -speed;
      break;
    case 'ArrowDown':
    case 's':
      pandaVelocity.z = speed;
      break;
  }
});

document.addEventListener('keyup', (e) => {
  switch(e.key) {
    case 'ArrowLeft':
    case 'ArrowRight':
    case 'a':
    case 'd':
      pandaVelocity.x = 0;
      break;
    case 'ArrowUp':
    case 'ArrowDown':
    case 'w':
    case 's':
      pandaVelocity.z = 0;
      break;
  }
});

function repositionBamboo() {
  bamboo.position.x = (Math.random() - 0.5) * 40;
  bamboo.position.z = (Math.random() - 0.5) * 40;
  bamboo.position.y = 0;
}

repositionBamboo();

function checkCollision() {
  const distance = panda.position.distanceTo(bamboo.position);
  return distance < 2;
}

function updateCamera() {
  const offset = new THREE.Vector3(
    Math.sin(cameraRotation) * 10,
    5,
    Math.cos(cameraRotation) * 10
  );
  camera.position.copy(panda.position).add(offset);
  camera.lookAt(panda.position);
  
  // Update directional light position to match camera rotation
  const lightOffset = new THREE.Vector3(
    Math.sin(cameraRotation) * 10,
    20,
    Math.cos(cameraRotation) * 10
  );
  directionalLight.position.copy(panda.position).add(lightOffset);
  directionalLight.target.position.copy(panda.position);
  directionalLight.target.updateMatrixWorld();
}

function animate() {
  requestAnimationFrame(animate);
  
  // Update movement relative to camera rotation
  const moveX = pandaVelocity.x * Math.cos(cameraRotation) - pandaVelocity.z * Math.sin(cameraRotation);
  const moveZ = pandaVelocity.x * Math.sin(cameraRotation) + pandaVelocity.z * Math.cos(cameraRotation);
  
  panda.position.x += moveX;
  panda.position.z += moveZ;
  
  // Keep panda within bounds
  panda.position.x = Math.max(-40, Math.min(40, panda.position.x));
  panda.position.z = Math.max(-40, Math.min(40, panda.position.z));
  
  // Update camera and light position
  updateCamera();
  
  // Animate bamboo
  bamboo.rotation.y += 0.02;
  bamboo.position.y = Math.sin(Date.now() * 0.003) * 0.5 + 1;
  
  if (checkCollision()) {
    score += 10;
    scoreElement.textContent = `Score: ${score}`;
    repositionBamboo();
  }
  
  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>

</body></html>