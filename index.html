<title>3D Fishing Adventure</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.1/dist/nipplejs.min.js"></script>
<style>
body { margin: 0; overflow: hidden; }
canvas { width: 100%; height: 100% }
#ui {
    position: fixed;
    top: 20px;
    left: 20px;
    color: white;
    font-family: Arial, sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 15px;
    border-radius: 10px;
}
#power-meter {
    width: 200px;
    height: 20px;
    background: #333;
    border-radius: 10px;
    overflow: hidden;
}
#power-fill {
    width: 0%;
    height: 100%;
    background: linear-gradient(90deg, #00ff00, #ff0000);
    transition: width 0.1s;
}
#shop {
    position: fixed;
    top: 20px;
    right: 20px;
    color: white;
    background: rgba(0,0,0,0.7);
    padding: 15px;
    border-radius: 10px;
}
#bag {
    position: fixed;
    bottom: 20px;
    right: 20px;
    color: white;
    background: rgba(0,0,0,0.7);
    padding: 15px;
    border-radius: 10px;
}
#joystick {
    position: fixed;
    bottom: 50px;
    left: 50px;
    width: 150px;
    height: 150px;
}
.shop-item {
    margin: 10px 0;
    padding: 5px;
    border: 1px solid white;
    cursor: pointer;
}
#game-over {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    display: none;
}
</style>
</head>
<body>
<div id="ui">
    <h2>3D Fishing</h2>
    <p>Score: <span id="score">0</span></p>
    <p>Money: $<span id="money">0</span></p>
    <div id="power-meter"><div id="power-fill"></div></div>
    <button id="cast-button" style="padding: 10px 20px; margin: 10px 0; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Cast Line</button>
    <p>Space to cast | Mouse to aim</p>
    <p style="color: red;">Watch out for evil fish!</p>
</div>
<div id="shop">
    <h3>Shop</h3>
    <div class="shop-item" onclick="buyItem('better-rod', 500)">Better Rod ($500)</div>
    <div class="shop-item" onclick="buyItem('bait', 100)">Bait ($100)</div>
    <div class="shop-item" onclick="buyItem('net', 1000)">Fishing Net ($1000)</div>
</div>
<div id="bag">
    <h3>Inventory</h3>
    <p>Fish caught: <span id="fishCount">0</span>/100</p>
    <p>Bait: <span id="baitCount">0</span></p>
    <p>Nets: <span id="netCount">0</span></p>
</div>
<div id="game-over">
    <h2>Game Over!</h2>
    <p>You were caught by an evil fish!</p>
    <button onclick="location.reload()">Try Again</button>
</div>
<div id="joystick"></div>
<script>
let scene, camera, renderer, water, rod, fishes = [], evilFishes = [], power = 0;
let casting = false;
let score = 0;
let money = 0;
let fishCount = 0;
let baitCount = 0;
let netCount = 0;
let joystick;
let moveSpeed = 0.1;
let gameOver = false;

init();
animate();

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(0, 1, 0);
    scene.add(directionalLight);

    const waterGeometry = new THREE.PlaneGeometry(100, 100);
    const waterMaterial = new THREE.MeshPhongMaterial({
        color: 0x0077be,
        transparent: true,
        opacity: 0.6
    });
    water = new THREE.Mesh(waterGeometry, waterMaterial);
    water.rotation.x = -Math.PI / 2;
    scene.add(water);

    const rodGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2);
    const rodMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
    rod = new THREE.Mesh(rodGeometry, rodMaterial);
    rod.position.set(0, 1, 2);
    scene.add(rod);

    for(let i = 0; i < 100; i++) {
        createFish();
    }

    for(let i = 0; i < 14; i++) {
        createEvilFish();
    }

    camera.position.set(0, 3, 5);
    camera.lookAt(0, 0, 0);

    joystick = nipplejs.create({
        zone: document.getElementById('joystick'),
        mode: 'static',
        position: { left: '50px', bottom: '50px' },
        color: 'white'
    });

    joystick.on('move', (evt, data) => {
        if (gameOver) return;
        const angle = data.angle.radian;
        const force = Math.min(data.force, 1);
        rod.position.x += Math.cos(angle) * force * moveSpeed;
        rod.position.z += Math.sin(angle) * force * moveSpeed;
        camera.position.x = rod.position.x;
        camera.position.z = rod.position.z + 3;
        camera.lookAt(rod.position);
    });

    const castButton = document.getElementById('cast-button');
    castButton.addEventListener('click', () => {
        if (!casting && !gameOver) {
            casting = true;
            castLine();
        }
    });

    window.addEventListener('resize', onWindowResize, false);
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('mousemove', onMouseMove);
}

function createFish() {
    const fishGroup = new THREE.Group();
    
    const bodyGeometry = new THREE.SphereGeometry(0.3, 32, 16);
    const bodyMaterial = new THREE.MeshPhongMaterial({ 
        color: Math.random() > 0.5 ? 0x4d89ff : 0xff6b6b,
        shininess: 70
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.scale.set(1, 0.7, 0.5);
    fishGroup.add(body);

    const snoutGeometry = new THREE.ConeGeometry(0.15, 0.3, 32);
    const snout = new THREE.Mesh(snoutGeometry, bodyMaterial);
    snout.position.x = 0.3;
    snout.rotation.z = -Math.PI / 2;
    fishGroup.add(snout);

    const tailGeometry = new THREE.BufferGeometry();
    const tailVertices = new Float32Array([
        0, 0, 0,      // center
        -0.4, 0.3, 0, // top
        -0.4, -0.3, 0 // bottom
    ]);
    tailGeometry.setAttribute('position', new THREE.BufferAttribute(tailVertices, 3));
    const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
    tail.position.x = -0.3;
    fishGroup.add(tail);

    const dorsalGeometry = new THREE.BufferGeometry();
    const dorsalVertices = new Float32Array([
        0, 0, 0,
        -0.2, 0.3, 0,
        0.2, 0.3, 0
    ]);
    dorsalGeometry.setAttribute('position', new THREE.BufferAttribute(dorsalVertices, 3));
    const dorsalFin = new THREE.Mesh(dorsalGeometry, bodyMaterial);
    dorsalFin.position.y = 0.3;
    fishGroup.add(dorsalFin);

    const pectoralGeometry = new THREE.BufferGeometry();
    const pectoralVertices = new Float32Array([
        0, 0, 0,
        0.2, -0.2, 0,
        -0.2, -0.2, 0
    ]);
    pectoralGeometry.setAttribute('position', new THREE.BufferAttribute(pectoralVertices, 3));
    
    const leftPectoralFin = new THREE.Mesh(pectoralGeometry, bodyMaterial);
    leftPectoralFin.position.set(0, -0.1, 0.2);
    leftPectoralFin.rotation.y = Math.PI / 4;
    fishGroup.add(leftPectoralFin);

    const rightPectoralFin = new THREE.Mesh(pectoralGeometry, bodyMaterial);
    rightPectoralFin.position.set(0, -0.1, -0.2);
    rightPectoralFin.rotation.y = -Math.PI / 4;
    fishGroup.add(rightPectoralFin);

    const eyeGeometry = new THREE.SphereGeometry(0.06);
    const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
    
    const leftEye = new THREE.Group();
    const leftEyeWhite = new THREE.Mesh(eyeGeometry, eyeMaterial);
    const leftEyePupil = new THREE.Mesh(new THREE.SphereGeometry(0.03), pupilMaterial);
    leftEyePupil.position.x = 0.04;
    leftEye.add(leftEyeWhite);
    leftEye.add(leftEyePupil);
    leftEye.position.set(0.2, 0.1, 0.15);
    fishGroup.add(leftEye);

    const rightEye = new THREE.Group();
    const rightEyeWhite = new THREE.Mesh(eyeGeometry, eyeMaterial);
    const rightEyePupil = new THREE.Mesh(new THREE.SphereGeometry(0.03), pupilMaterial);
    rightEyePupil.position.x = 0.04;
    rightEye.add(rightEyeWhite);
    rightEye.add(rightEyePupil);
    rightEye.position.set(0.2, 0.1, -0.15);
    fishGroup.add(rightEye);

    for(let i = 0; i < 20; i++) {
        const scaleGeometry = new THREE.SphereGeometry(0.05);
        const scaleMaterial = new THREE.MeshPhongMaterial({
            color: bodyMaterial.color,
            opacity: 0.5,
            transparent: true
        });
        const scale = new THREE.Mesh(scaleGeometry, scaleMaterial);
        scale.position.set(
            (Math.random() - 0.5) * 0.6,
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3
        );
        scale.scale.set(1, 0.1, 1);
        fishGroup.add(scale);
    }

    fishGroup.position.set(Math.random() * 80 - 40, 0.1, Math.random() * 80 - 40);
    scene.add(fishGroup);
    fishes.push(fishGroup);
}

function createEvilFish() {
    const evilFishGroup = new THREE.Group();
    
    const bodyGeometry = new THREE.SphereGeometry(0.4, 32, 16);
    const bodyMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x660000,
        shininess: 70,
        roughness: 0.8
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.scale.set(1.2, 0.8, 0.6);
    evilFishGroup.add(body);

    const snoutGeometry = new THREE.ConeGeometry(0.2, 0.4, 32);
    const snout = new THREE.Mesh(snoutGeometry, bodyMaterial);
    snout.position.x = 0.4;
    snout.rotation.z = -Math.PI / 2;
    evilFishGroup.add(snout);

    const tailGeometry = new THREE.BufferGeometry();
    const tailVertices = new Float32Array([
        0, 0, 0,
        -0.6, 0.4, 0,
        -0.6, -0.4, 0,
        -0.8, 0, 0
    ]);
    tailGeometry.setAttribute('position', new THREE.BufferAttribute(tailVertices, 3));
    const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
    tail.position.x = -0.4;
    evilFishGroup.add(tail);

    const dorsalGeometry = new THREE.BufferGeometry();
    const dorsalVertices = new Float32Array([
        0, 0, 0,
        -0.3, 0.5, 0,
        0.3, 0.5, 0,
        0, 0.7, 0
    ]);
    dorsalGeometry.setAttribute('position', new THREE.BufferAttribute(dorsalVertices, 3));
    const dorsalFin = new THREE.Mesh(dorsalGeometry, bodyMaterial);
    dorsalFin.position.y = 0.3;
    evilFishGroup.add(dorsalFin);

    const eyeGeometry = new THREE.SphereGeometry(0.08);
    const eyeMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 0.5
    });
    
    const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
    leftEye.position.set(0.2, 0.1, 0.2);
    evilFishGroup.add(leftEye);

    const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
    rightEye.position.set(0.2, 0.1, -0.2);
    evilFishGroup.add(rightEye);

    const teethGeometry = new THREE.ConeGeometry(0.04, 0.1, 4);
    const teethMaterial = new THREE.MeshPhongMaterial({ color: 0xffffcc });
    
    for(let i = 0; i < 8; i++) {
        const tooth = new THREE.Mesh(teethGeometry, teethMaterial);
        tooth.position.set(
            0.3,
            -0.1 + Math.sin(i * 0.8) * 0.1,
            -0.15 + i * 0.04
        );
        tooth.rotation.z = Math.PI / 4;
        evilFishGroup.add(tooth);
    }

    for(let i = 0; i < 6; i++) {
        const spikeGeometry = new THREE.ConeGeometry(0.05, 0.2, 4);
        const spike = new THREE.Mesh(spikeGeometry, bodyMaterial);
        spike.position.set(
            -0.2 + i * 0.15,
            0.3,
            0
        );
        spike.rotation.z = -Math.PI / 6;
        evilFishGroup.add(spike);
    }

    evilFishGroup.position.set(
        Math.random() * 80 - 40,
        0.1,
        Math.random() * 80 - 40
    );
    scene.add(evilFishGroup);
    evilFishes.push(evilFishGroup);
}

function checkEvilFishCollision() {
    for (let evilFish of evilFishes) {
        const distance = rod.position.distanceTo(evilFish.position);
        if (distance < 1) {
            gameOver = true;
            document.getElementById('game-over').style.display = 'block';
        }
    }
}

function updateEvilFish() {
    evilFishes.forEach(evilFish => {
        const directionX = rod.position.x - evilFish.position.x;
        const directionZ = rod.position.z - evilFish.position.z;
        const length = Math.sqrt(directionX * directionX + directionZ * directionZ);
        
        if (length > 0) {
            evilFish.position.x += (directionX / length) * 0.05;
            evilFish.position.z += (directionZ / length) * 0.05;
            
            evilFish.rotation.y = Math.atan2(directionX, directionZ);
        }
    });
}

function buyItem(item, cost) {
    if (money >= cost) {
        money -= cost;
        document.getElementById('money').textContent = money;
        switch(item) {
            case 'better-rod':
                moveSpeed *= 1.5;
                break;
            case 'bait':
                baitCount++;
                document.getElementById('baitCount').textContent = baitCount;
                break;
            case 'net':
                netCount++;
                document.getElementById('netCount').textContent = netCount;
                break;
        }
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onKeyDown(event) {
    if (event.code === 'Space' && !casting && !gameOver) {
        casting = true;
        castLine();
    }
}

function onMouseMove(event) {
    if (!casting && !gameOver) {
        const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        rod.rotation.y = mouseX;
    }
}

function castLine() {
    let powerInterval = setInterval(() => {
        power += 2;
        if (power > 100) power = 0;
        document.getElementById('power-fill').style.width = power + '%';
    }, 50);

    const stopCasting = () => {
        clearInterval(powerInterval);
        window.removeEventListener('keyup', onSpaceUp);
        document.removeEventListener('mouseup', onButtonUp);
        throwLine();
    };

    const onSpaceUp = (event) => {
        if (event.code === 'Space') {
            stopCasting();
        }
    };

    const onButtonUp = () => {
        stopCasting();
    };

    window.addEventListener('keyup', onSpaceUp);
    document.getElementById('cast-button').addEventListener('mouseup', onButtonUp, { once: true });
}

function throwLine() {
    const distance = (power / 100) * 10;
    const targetX = rod.position.x + Math.sin(rod.rotation.y) * distance;
    const targetZ = rod.position.z + Math.cos(rod.rotation.y) * distance;

    fishes.forEach((fish, index) => {
        const fishDistance = Math.sqrt(
            Math.pow(targetX - fish.position.x, 2) +
            Math.pow(targetZ - fish.position.z, 2)
        );

        if (fishDistance < 1) {
            catchFish(index);
        }
    });

    setTimeout(() => {
        casting = false;
        power = 0;
        document.getElementById('power-fill').style.width = '0%';
    }, 1000);
}

function catchFish(index) {
    score += 100;
    money += 50;
    fishCount++;
    document.getElementById('score').textContent = score;
    document.getElementById('money').textContent = money;
    document.getElementById('fishCount').textContent = fishCount;
    
    scene.remove(fishes[index]);
    fishes.splice(index, 1);
    
    if (fishCount < 100) {
        setTimeout(() => {
            createFish();
        }, 1000);
    }
}

function animate() {
    if (gameOver) return;
    
    requestAnimationFrame(animate);

    water.material.opacity = 0.6 + Math.sin(Date.now() * 0.001) * 0.1;

    fishes.forEach(fish => {
        fish.position.x += Math.sin(Date.now() * 0.001 + fish.position.z) * 0.02;
        fish.position.z += Math.cos(Date.now() * 0.001 + fish.position.x) * 0.02;
        fish.rotation.y = Math.sin(Date.now() * 0.003) * 0.1;
    });

    updateEvilFish();
    checkEvilFishCollision();

    renderer.render(scene, camera);
}
</script>
</body>
</html>