<style>
  body {
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background: #1a1a1a;
    overflow: hidden;
  }

  #gameContainer {
    position: relative;
    width: min(90vw, 90vh);
    height: min(90vw, 90vh);
  }

  #gameCanvas {
    position: absolute;
    border-radius: 50%;
    background: #000;
    width: 100%;
    height: 100%;
    touch-action: none;
  }

  .mask {
    position: absolute;
    width: 100%;
    height: 100%;
    background: #1a1a1a;
    clip-path: circle(50% at center);
  }

  @keyframes flash {
    0% { opacity: 0; transform: scale(0); }
    50% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(1.5); }
  }

  .flash {
    position: absolute;
    pointer-events: none;
    background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
    width: 100px;
    height: 100px;
    border-radius: 50%;
    animation: flash 0.5s ease-out forwards;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <div class="mask">
    <canvas id="gameCanvas" width="600" height="600"></canvas>
  </div>
</div>

<script>class Snake {
  constructor(x, y, color, isFirstSnake = false, canvas) {
    this.segments = [{
      x,
      y
    }];
    const angle = Math.random() * Math.PI * 2;
    this.velocity = {
      x: Math.cos(angle) * 2,
      y: Math.sin(angle) * 2
    };
    this.color = isFirstSnake ? 'hsl(120, 80%, 50%)' : color || `hsl(${Math.random() * 360}, 80%, 50%)`;
    this.length = 20;
    this.opacity = 1;
    this.targetSpeed = window.innerWidth < 768 ? 1.4 : 2;
    this.currentSpeed = this.targetSpeed;
    this.hue = parseInt(this.color.match(/hsl\((\d+)/)[1]);
    this.canvas = canvas;
    this.eyeOffset = Math.random() * 2 + 2;
    this.eyeSize = Math.random() * 1.5 + 1;
    this.eyeAngle = Math.random() * 0.6 - 0.3;
  }
  update(food, otherSnakes) {
    let closestFood = null;
    let closestDist = Infinity;
    food.forEach(f => {
      const dist = Math.hypot(this.segments[0].x - f.x, this.segments[0].y - f.y);
      if (dist < closestDist) {
        closestDist = dist;
        closestFood = f;
      }
    });
    let targetX = 0;
    let targetY = 0;
    let avoidanceX = 0;
    let avoidanceY = 0;
    const avoidanceDistance = 30;
    if (closestFood) {
      const dx = closestFood.x - this.segments[0].x;
      const dy = closestFood.y - this.segments[0].y;
      const foodDist = Math.hypot(dx, dy);
      targetX = dx / foodDist;
      targetY = dy / foodDist;
      let shouldYield = false;
      otherSnakes.forEach(otherSnake => {
        if (otherSnake === this) return;
        const otherDist = Math.hypot(otherSnake.segments[0].x - closestFood.x, otherSnake.segments[0].y - closestFood.y);
        if (otherDist < closestDist * 1.5) {
          const otherHue = otherSnake.hue;
          const thisGreenDist = Math.abs(120 - this.hue);
          const otherGreenDist = Math.abs(120 - otherHue);
          if (otherGreenDist < thisGreenDist) {
            shouldYield = true;
          }
        }
      });
      if (shouldYield) {
        const perpX = -targetY;
        const perpY = targetX;
        targetX = perpX;
        targetY = perpY;
      }
    }
    otherSnakes.forEach(otherSnake => {
      if (otherSnake === this) return;
      otherSnake.segments.forEach(segment => {
        const dist = Math.hypot(this.segments[0].x - segment.x, this.segments[0].y - segment.y);
        if (dist < avoidanceDistance) {
          const dx = this.segments[0].x - segment.x;
          const dy = this.segments[0].y - segment.y;
          const factor = (avoidanceDistance - dist) / avoidanceDistance;
          avoidanceX += dx / dist * factor;
          avoidanceY += dy / dist * factor;
        }
      });
    });
    const avoidanceStrength = 2;
    targetX += avoidanceX * avoidanceStrength;
    targetY += avoidanceY * avoidanceStrength;
    const targetMagnitude = Math.hypot(targetX, targetY);
    if (targetMagnitude > 0) {
      targetX /= targetMagnitude;
      targetY /= targetMagnitude;
    }
    if (targetX !== 0 || targetY !== 0) {
      this.velocity.x += (targetX * this.currentSpeed - this.velocity.x) * 0.2;
      this.velocity.y += (targetY * this.currentSpeed - this.velocity.y) * 0.2;
    }
    const newHead = {
      x: this.segments[0].x + this.velocity.x,
      y: this.segments[0].y + this.velocity.y
    };
    const center = {
      x: this.canvas.width / 2,
      y: this.canvas.height / 2
    };
    const radius = this.canvas.width / 2.07;
    const distToCenter = Math.hypot(newHead.x - center.x, newHead.y - center.y);
    if (distToCenter > radius) {
      const angle = Math.atan2(newHead.y - center.y, newHead.x - center.x);
      newHead.x = center.x + Math.cos(angle) * (radius * 0.95);
      newHead.y = center.y + Math.sin(angle) * (radius * 0.95);
      const tangentAngle = angle + Math.PI / 2;
      this.velocity.x = Math.cos(tangentAngle) * this.currentSpeed;
      this.velocity.y = Math.sin(tangentAngle) * this.currentSpeed;
    }
    this.segments.unshift(newHead);
    while (this.segments.length > this.length) {
      this.segments.pop();
    }
  }
  grow() {
    this.length += 10;
  }
  draw(ctx) {
    ctx.beginPath();
    ctx.moveTo(this.segments[0].x, this.segments[0].y);
    this.segments.forEach(segment => {
      ctx.lineTo(segment.x, segment.y);
    });
    ctx.strokeStyle = this.color;
    ctx.lineWidth = window.innerWidth < 768 ? 4.8 : 8;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();
    if (this.segments.length >= 2) {
      const head = this.segments[0];
      const neck = this.segments[1];
      const dx = head.x - neck.x;
      const dy = head.y - neck.y;
      const angle = Math.atan2(dy, dx);
      const rightEyeX = head.x + Math.cos(angle - Math.PI / 2 + this.eyeAngle) * this.eyeOffset;
      const rightEyeY = head.y + Math.sin(angle - Math.PI / 2 + this.eyeAngle) * this.eyeOffset;
      const leftEyeX = head.x + Math.cos(angle + Math.PI / 2 + this.eyeAngle) * this.eyeOffset;
      const leftEyeY = head.y + Math.sin(angle + Math.PI / 2 + this.eyeAngle) * this.eyeOffset;
      ctx.beginPath();
      ctx.arc(rightEyeX, rightEyeY, this.eyeSize, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(leftEyeX, leftEyeY, this.eyeSize, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
    }
  }
}
class Game {
  constructor() {
    this.canvas = document.getElementById('gameCanvas');
    const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.9);
    this.canvas.width = size;
    this.canvas.height = size;
    this.ctx = this.canvas.getContext('2d');
    const randAngle = Math.random() * Math.PI * 2;
    const randDist = Math.random() * (size / 6);
    const startX = size / 2 + Math.cos(randAngle) * randDist;
    const startY = size / 2 + Math.sin(randAngle) * randDist;
    this.snakes = [new Snake(startX, startY, null, true, this.canvas)];
    this.food = [];
    this.currentLine = null;
    this.dragHistory = [];
    this.setupEvents();
    this.spawnFood();
    this.gameLoop();
    window.addEventListener('resize', () => {
      const newSize = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.9);
      this.canvas.width = newSize;
      this.canvas.height = newSize;
      this.snakes.forEach(snake => {
        snake.targetSpeed = window.innerWidth < 768 ? 1.4 : 2;
        snake.currentSpeed = snake.targetSpeed;
      });
    });
  }
  createFlashEffect(x, y) {
    const flash = document.createElement('div');
    flash.className = 'flash';
    flash.style.left = x - 50 + 'px';
    flash.style.top = y - 50 + 'px';
    document.getElementById('gameContainer').appendChild(flash);
    setTimeout(() => flash.remove(), 500);
  }
  setupEvents() {
    const getEventCoords = e => {
      const rect = this.canvas.getBoundingClientRect();
      const event = e.touches ? e.touches[0] : e;
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
        timestamp: Date.now()
      };
    };
    const handleStart = e => {
      e.preventDefault();
      const point = getEventCoords(e);
      this.currentLine = [point];
      this.dragHistory = [...this.currentLine];
    };
    const handleMove = e => {
      e.preventDefault();
      if (this.currentLine) {
        const newPoint = getEventCoords(e);
        this.currentLine.push(newPoint);
        this.dragHistory.push(newPoint);
        this.checkCuts(this.currentLine[this.currentLine.length - 2], newPoint);
      }
    };
    const handleEnd = e => {
      e.preventDefault();
      this.currentLine = null;
    };
    this.canvas.addEventListener('mousedown', handleStart);
    this.canvas.addEventListener('mousemove', handleMove);
    this.canvas.addEventListener('mouseup', handleEnd);
    this.canvas.addEventListener('mouseleave', handleEnd);
    this.canvas.addEventListener('touchstart', handleStart);
    this.canvas.addEventListener('touchmove', handleMove);
    this.canvas.addEventListener('touchend', handleEnd);
    this.canvas.addEventListener('touchcancel', handleEnd);
  }
  spawnFood() {
    if (this.food.length < 5) {
      const angle = Math.random() * Math.PI * 2;
      const radius = Math.random() * (this.canvas.width / 2.4);
      this.food.push({
        x: this.canvas.width / 2 + Math.cos(angle) * radius,
        y: this.canvas.height / 2 + Math.sin(angle) * radius
      });
    }
  }
  checkCuts(point1, point2) {
    if (!point1 || !point2) return;
    this.snakes.forEach((snake, snakeIndex) => {
      for (let i = 1; i < snake.segments.length; i++) {
        const seg1 = snake.segments[i - 1];
        const seg2 = snake.segments[i];
        if (this.lineIntersects(seg1, seg2, point1, point2)) {
          const intersectionX = (seg1.x + seg2.x) / 2;
          const intersectionY = (seg1.y + seg2.y) / 2;
          this.createFlashEffect(intersectionX, intersectionY);
          const angle = Math.atan2(seg2.y - seg1.y, seg2.x - seg1.x) + Math.PI / 2;
          const separation = 10;
          const offsetX1 = Math.cos(angle) * separation;
          const offsetY1 = Math.sin(angle) * separation;
          const offsetX2 = -offsetX1;
          const offsetY2 = -offsetY1;
          const snake1 = new Snake(intersectionX + offsetX1, intersectionY + offsetY1, `hsl(${Math.random() * 360}, 80%, 50%)`, false, this.canvas);
          snake1.segments = snake.segments.slice(0, i).map(seg => ({
            x: seg.x + offsetX1,
            y: seg.y + offsetY1
          }));
          snake1.length = snake1.segments.length;
          const snake2 = new Snake(intersectionX + offsetX2, intersectionY + offsetY2, `hsl(${Math.random() * 360}, 80%, 50%)`, false, this.canvas);
          snake2.segments = snake.segments.slice(i).map(seg => ({
            x: seg.x + offsetX2,
            y: seg.y + offsetY2
          }));
          snake2.length = snake2.segments.length;
          this.snakes.splice(snakeIndex, 1, snake1, snake2);
          return;
        }
      }
    });
  }
  lineIntersects(p1, p2, p3, p4) {
    const denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
    if (denominator === 0) return false;
    const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;
    return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
  }
  checkCollisions() {
    this.snakes.forEach(snake => {
      this.food = this.food.filter(food => {
        const dist = Math.hypot(snake.segments[0].x - food.x, snake.segments[0].y - food.y);
        if (dist < 10) {
          snake.grow();
          return false;
        }
        return true;
      });
      const otherSnakes = this.snakes.filter(s => s !== snake);
      snake.update(this.food, otherSnakes);
    });
  }
  gameLoop() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.beginPath();
    this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, this.canvas.width / 2.07, 0, Math.PI * 2);
    this.ctx.strokeStyle = '#333';
    this.ctx.lineWidth = 4;
    this.ctx.stroke();
    this.snakes.forEach(snake => snake.draw(this.ctx));
    const foodRadius = window.innerWidth < 768 ? 3.5 : 5;
    this.food.forEach(food => {
      this.ctx.beginPath();
      this.ctx.arc(food.x, food.y, foodRadius, 0, Math.PI * 2);
      this.ctx.fillStyle = '#f00';
      this.ctx.fill();
    });
    const currentTime = Date.now();
    const fadeTime = 400;
    this.dragHistory = this.dragHistory.filter(point => currentTime - point.timestamp <= fadeTime);
    if (this.dragHistory.length > 1) {
      for (let i = 1; i < this.dragHistory.length; i++) {
        const point1 = this.dragHistory[i - 1];
        const point2 = this.dragHistory[i];
        const opacity = 1 - (currentTime - point2.timestamp) / fadeTime;
        this.ctx.beginPath();
        this.ctx.moveTo(point1.x, point1.y);
        this.ctx.lineTo(point2.x, point2.y);
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
      }
    }
    this.checkCollisions();
    this.spawnFood();
    requestAnimationFrame(() => this.gameLoop());
  }
}
new Game();</script>
</body></html>